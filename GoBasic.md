## 一、初识 Go

### 1、安装 & 配置

> [Go 官网](https://golang.google.cn/)

（1）Windows

下载解压 `go1.17.windows-amd64.zip` 就得到 Go SDK 环境，配置环境变量即可开始使用。

（2）Linux

> BUG：直接下载 go**.tar.gz 到 Linux 后，无法解压。

````
# 将 Windows 下载好的 go1.17.linux-amd64.tar.gz 复制到 Linux
scp ./go1.17.linux-amd64.tar.gz root@192.168.56.101:/tmp

# 解压
tar -zxvf go1.17.linux-amd64.tar.gz

# 将解压得到的 go 文件夹移动合适位置
mv go /usr/local

# 配置环境变量
vi /etc/profile

```
# 配置 GOROOT 和 GOPATH
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin

# go1.13 之后的版本都是用 gomod
# GOPATH 随便指定个地方就可以了，第三方依赖会下载到那里
export GOPATH=/GoPath
```

# 立即生效
source /etc/profile 

# 安装成功
> go version
go version go1.17 linux/amd64

# 开启 GOMODULE 模式
go env -w GO111MODULE=on
````

> GO 必要配置说明

| 环境变量 | 说明            | 路径           |
| -------- | --------------- | -------------- |
| GOROOT   | SDK 的安装路径  | `D:\go`        |
| Path     | SDK 的 bin 目录 | `D:\go\bin`    |
| GOPATH   | 工作目录        | `D:\GoProject` |



### 2、Go Modules

> Go 的依赖管理工具，代替 GOPATH 模式。

（1）go mod 命令

| 命令            | 说明                                 |
| --------------- | ------------------------------------ |
| go mod init     | 生成 go.mod 文件                     |
| go mod download | 下载 go.mod 文件中列出的依赖项       |
| go mod tidy     | 整理现有依赖（自动增删使用到的模块） |
| go mod graph    | 查看现有的依赖结构                   |
| go mod edit     | 编辑 go.mod 文件                     |
| go mod vendor   | 导出项目的所有依赖到 vendor 目录     |
| go mod verify   | 校验一个模块是否被篡改               |
| go mod why      | 查看为什么依赖该模块                 |

（2）go mod 环境变量

> 设置环境变量：`go env -w 变量名 = 变量值`

```ini
$ go evn

# Go Modules 的开关
# auto：只要项目包含 go.mod 文件就启用 Go Modules
# on：启用 Go Modules
# off：禁用 Go Modules
GO111MODULE="auto"

# 设置 Go 模块代理
# 默认为：https://proxy.golang.org,direct （国外）
# 推荐：https://mirrors.aliyun.com/goproxy （阿里）
# https://goproxy.cn （七牛）
# direct：当设置的代理中找不到包时，尝试从指定源中获取
GOPROXY="https://goproxy.cn,https://mirrors.aliyun.com/goproxy,direct"

# 校验下载包是否完整
# 设置 GOPROXY 后不用设置该项
GOSUMDB=

# 依赖私有模块时配置
# 一般设置 GOPRIVATE 即可，其值会作为 GONOPROXY 和 GONOSUMDB 的默认值
GONOPROXY=
GONOSUMDB=
GOPRIVATE=
...
```

（3）go mod 初始化项目

> 开启 go modules 

```
go env -w GO111MODULE=on
```

> 初始化

```
go mod init 模块名
```

> 获取需要的模块（以 Redis 为例）
>

```
go get github.com/garyburd/redigo/redis
```

会生成 go.sum 文件，并在 go.mod 文件中添加一行。

```
require github.com/garyburd/redigo v1.6.2

// indirect 间接依赖
```

> 完成上述步骤后，即可正常使用

```go
package main

import (
	"fmt"
	"github.com/garyburd/redigo/redis"
)

func main(){
	// 连接 Redis 服务
	c, err := redis.Dial("tcp", "127.0.0.1:6379")
	if err != nil {
		fmt.Println("连接出错：", err)
		return
	}

	// 关闭连接
	defer c.Close()

	// 执行命令
	c.Do("auth", "ycz")
	c.Do("set", "name", "YCZ")
    
	// 将结果转换成 string
	res, err := redis.String(c.Do("get", "name"))
	if err != nil {
		fmt.Println("执行出错：", err)
		return
	}

	fmt.Println("结果：", res)
}
```

> 对比 GOPATH 模式：
>

GOPATH 模式将所需模块下载到 $GOPATH/src/... 

GOMODULES 模式将所需模块下载到 $GOPATH/pkg/mod/... 

（4）Goland 中找不到 GOROOT

> 编辑文件：$GOROOT\src\runtime\internal\sys\zversion.go

```go
// Code generated by go tool dist; DO NOT EDIT.

package sys

const TheVersion = `go1.17`
const Goexperiment = ``
const StackGuardMultiplierDefault = 1
```

（5）GOPATH 模式（已弃用）

> 启用 GOPATH 模式： 

- `go env -w GO111MODULE=off`

> 在 $GOPATH 目录下新建三个目录：

- bin：存放编译后生成的可执行文件；

- pkg：存放编译后生成的归档文件；

- src：存放源码文件，自定义包也是从该目录下寻找的。

> GOPATH 缺点：
>

- 无版本控制概念；



### 3、HelloWorld

> hello.go

```go
// 文件所在包（文件夹），类似命名空间
package main 

// 引入一个包
import "fmt" 

// 声明主函数，程序入口
func main() { 
    // 调用 fmt 包中的输出函数
	fmt.Println("hello world") 
}
```

> 编译
>

生成可执行 hello.exe 文件（可在任意环境下执行）

```
# 用法
go build [-o output] [build flags] [packages]

go build hello.go
```

> 直接运行

```
go run hello.go
```

### 4、常用命令

```
go env 			查看环境变量
go run 			命令可以编译并运行命令源码文件。
go get 			可以根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装。
go build 		命令用于编译我们指定的源码文件或代码包以及它们的依赖包。
go install 		用于编译并安装指定的代码包及它们的依赖包。
go clean 		命令会删除掉执行其它命令时产生的一些文件和目录。
go doc 			命令可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。
go test 		命令用于对Go语言编写的程序进行测试。
go list 		命令的作用是列出指定的代码包的信息。
go fix 			会把指定代码包的所有Go语言源码文件中的旧版本代码修正为新版本的代码。
go vet 			代码静态分析，是一个用于检查Go语言源码中静态错误的简单工具。
go tool pprof 	命令来交互式的访问概要文件的内容。
```

### 5、特点

（1）部署简单：可直接编译成机器码、直接运行；

（2）静态语言：编译时检查错误；

（3）天生高并发；

（4）强大的标准库；



## 二、Go 基础

> Go 的声明语法：
>
> var（声明变量）
>
> const（声明常量）
>
> type（声明类型）
>
> func（声明函数）

### 1、变量

```go
package main

import "fmt"

// 声明全局变量（不能用 := 方式）
var name string = "YCZ"
var age int = 18

var (
	n2 string = "lw"
	a2 int    = 20
)

func main() {
    var a int       // 声明变量，默认为 0
	var b = 1       // 声明变量并初始化，类型自动推导
	c := 2          // 语法糖定义
	var x, y, z int // 定义多个变量
    
	// 声明变量 方式1
	var s1 string = "ABC"
	var i1 int = 10
	fmt.Println("\n s1: ", s1, "\n i1: ", i1)

	// 声明多个变量 1：一次声明多个同类型的变量
	var ss1, ss2, ss3 string = "AAA", "BBB", "CCC"
	fmt.Println("\n ss1: ", ss1, "\n ss2: ", ss2, "\n ss3: ", ss3)

	// 声明变量 方式2：自动类型
	var s2 = "DEF"
	var i2 = 20
	fmt.Println("\n s2: ", s2, "\n i2: ", i2)

	// 声明多个变量 2：自动类型
	var ii1, ii2, ii3 = "DDD", 11, "FFF"
	fmt.Println("\n ii1: ", ii1, "\n ii2: ", ii2, "\n ii3", ii3)

	// 声明变量 方式3：自动类型
	s3 := "GHI"
	i3 := 30
	fmt.Println("\n s3: ", s3, "\n i3: ", i3)

	// 声明多个变量 3：自动类型
	sss1, sss2, sss3 := 31, "HHH", 32
	fmt.Println("\n sss1: ", sss1, "\n sss2: ", sss2, "\n sss3: ", sss3)

	// 输出全局变量
	fmt.Println("\n name: ", name, "\n age: ", age, "\n n2: ", n2, "\n a2: ", a2)
    
    // 匿名变量，常用于接收不需要的多个函数返回值
    res, _ = test()
}
```

### 2、常量

```go
const length int = 10

// 同时声明多个常量时，如果省略了值，则默认与上一行的值相同
const (
	m1 = 100 
    m2
    m3
)

/**
 * iota 是 go 的常量计数器，只能在const表达式中使用
 * iota 默认为 0，每行加 1
 */
const (
	n1 = iota // 0
    n2
    n3
)

const (
	m1, m2 = iota + 1, iota + 2 // iota=0, m1=1, m2=2
    m3, m4                      // iota=1, m3=2, m4=3
    
    n1, n2 = iota * 1, iota * 2 // iota=2, n1=2, n2=4
    n3, n4                      // iota=3, n3=3, n4=6
)

const (
    _  = iota
    KB = 1 << (10 * iota)
    MB = 1 << (10 * iota)
    GB = 1 << (10 * iota)
    TB = 1 << (10 * iota)
    PB = 1 << (10 * iota)
)
```

### 3、运算符

```
/	两个整数相除结果也是整数，当有小数参与运算时结果才会有小数

+	加号两边都是数值型时，做加法运算，否则做字符串拼接

++、--	只能单独使用，不能联合其它运算符，且没有前置操作

= 赋值运算符

// Go 支持多重赋值，交换变量值
i, j = j, i
```

位运算符

> 位运算都是拿补码来进行的
>
> 正数的原码、反码、补码都一样
>
> 负数的反码为符号位不变其余为取反，补码为反码加1
>
> 注：负数做完位运算以后，还要将计算结果（补码）转换成原码

```
&	按位与
|	按位或
^	按位异或
<<	左移位：符号位不变，低位补0
>>	右移位：低位溢出，符号位不变，并用符号位补溢出的高位
```

### 4、数据类型 - 值类型

#### （1）数值型

> 默认值：0

```
# 有符号，数字表示位，如 int8 => 1字节
int
int8
int16
int32
int64

# 无符号
uint
uint8
uint16
uint32
uint64

int 和 uint 位数相同，由具体平台实现指定长度：32 或 64 位
uintptr 能够容纳指针值的无符号整数

# 浮点型
float32
float64

complex64	实部虚部都为 float32 的复数集合
complex128	实部虚部都为 float64 的复数集合

byte	uint8 的别名，存储单个字符（ASCII 表中的字符）
rune	int32 的别名，表示一个 UTF-8 字符，中文用
```

#### （2）字符型

> 没有专门的字符型，用 byte 来保存单个字符；
>
> 字符用单引号括起来；

```go
var state byte = 'A'
# 直接输出的是字符对应是 ASCII 码值，65
fmt.Println("state=", state)
# 输出原字符
fmt.Printf("state=%c", state)
```

#### （3）布尔型

> bool 型占1字节，默认值：false。

```
true 
false
```

#### （4）字符串

> 默认值：""
>
> 字符串用双引号括起来；
>
> 当需要输出特殊字符或跨行字符串时，用反引号括起来。
>
> 可以用 str[0] 获取字符串中的某个字符；
>
> 可以用 `+` 拼接字符串，当需要换行拼接时，`+` 留在上一行；

```go
var string = "YCZ"

// 多行字符串
str := `
第一行
第二行
`
```

> 字符串函数

```
len(str)	求长度
+或fmt.Sprintf	拼接字符串
strings.Split	分割
strings.Contains	判断是否包含
strings.HasPrefix,strings.HasSuffix	前缀/后缀判断
strings.Index(),strings.LastIndex()	子串出现的位置
strings.Join(a[]string, sep string)	join操作
```

> 获取字符串长度

```
使用 bytes.Count() 统计
使用 strings.Count() 统计
将字符串转换为 []rune 后调用 len 函数进行统计
使用 utf8.RuneCountInString()统计
```

#### （5）数组

> 同类型的固定长度的序列。
>
> 长度也是数组类型的一部分。
>
> 指针数组 [n]*T，数组指针 *[n]T。

```go
// 定义
var arr1 = [5]int{1,2,3,4,5}
// 自动确定元素个数
var arr2 = [...]int{6,7,8,9}
// 指定下标对应的元素
var arr3 = [2]string{0: "y", 1:"c", 2:"z"}

// for range 遍历数组，下标越界会触发 panic
for key, val := range arr3 {
    fmt.Println(key, val)
}

// 二维数组
var arr2w = [2][3]int {{1,2,3},{4,5,6}}

// 创建多维数组时，只允许在第一维度使用 ...
var arr2w = [...][3]int = {{1,2,3},{4,5,6}}
```

#### （6）结构体

```go
type <Name> struct {
    <属性> <类型>
    <属性> <类型>
    ...
}

type User struct {
    name string
    age int
}

type Admin struct {
	name string
    age int
}

// 完全初始化
stu1 := User{"YCZ", 20}
// 部分初始化，必须通过属性名称指定要初始化的属性
stu2 := User{name: "YYY"}

var admin Admin
admin = Admin(stu1)

type Person struct {
    Admin	// 匿名属性，结构体
    class string
}

person := Person{admin, "管理员"}
// 访问匿名结构体中的属性-方式1
person.Admin.name
// 访问匿名结构体中的属性-方式2：若存在重名属性，则优先级：本结构体属性＞匿名结构体属性
// 注意：如果有多个匿名结构体的属性名相同，则只能用方式1访问
person.name
```

注：

- 结构体定义好后（不初始化），各属性都有各自对应的默认值，可以直接使用了。
- slice、map 类型属性的默认值是 nil ，不能直接使用。
- 结构体类型转换：属性名、属性类型、属性个数、排列顺序都是结构体的组成部分，只有两个结构完全相同的结构体类型才能转换。
- 匿名属性：不指定属性名，只有属性类型的属性叫匿名属性。此时数据类型用作属性名。
  - 最常见的匿名属性是将结构体类型的属性定义为匿名属性。

#### （7）自定义类型

```go
type 自定义类型名称 数据类型
```



### 5、数据类型 - 引用类型

> 注意：
>
> - 引用类型用 `=` 赋值时，实质是指向同一内存地址（浅拷贝）。
> - 引用类型作为函数参数时，注意函数内的修改会改变原始对象（引用传递）。

#### （1）指针（Pointer）

> 默认值：nil
>
> 长度由操作系统决定：32位操作系统中占4字节；64位操作系统中占8字节。

```go
var i int = 10
fmt.Printf("变量i的地址：%v \n", &i)

var ptr *int = &i
fmt.Printf("指针变量的值 ptr：%v \n", ptr)
fmt.Printf("指针变量的地址 &ptr：%v \n", &ptr)
fmt.Printf("指针指向的值 *ptr：%v \n", *ptr)

type User struct {
    name string
    age int
}
// 指向结构体的指针
var poi = &User  // &{ 0 }
poi.name = "YCZ" // Go的语法糖操作，底层自动转换为：*(poi).name
```

注：

- 指针作为函数返回值时，可以将函数内的局部变量作为返回值，但不能将函数内的指向局部变量的指针作为返回值，函数结束时指向的空间会被释放。

#### （2）切片（slice）

> 声明后需要 make 内存空间才能使用。

```go
// 切片定义1：引用已存在的数组，引用全部 [:]
var slice = arr[1:3]    // arr[1:3)
/**
 * 通过数组生成切片的注意事项：
 * 1、arr[0:len(arr)] 通过区间方式获取数组元素时，左边默认值为0，右边默认值为 len(arr)，且为左闭右开区间 [0:len)。
 * 2、通过区间方式生成的切片长度为实际截取长度，容量为数组长度 len(arr)。
 * 3、slice1 = slice2 为引用传递，底层数组指向同一地址，修改底层数组时两个切片都会变化。
 * 4、用 copy() 函数实现值传递，拷贝一份数组元素，开辟新空间。
 * 5、append() 函数操作切片时，会改变底层数组；仅当 slice 容量不足时，会新开辟数组后追加元素，原数组才不会改变。
 */

// 切片定义2：通过 make 来创建切片
var slice []int = make([] int, len, [cap])

// 切片定义3：直接定义
var slice []int = []int {1, 2, 3}

// 数据结构
| 数组起始地址 | len | cap |
```

> string 与 切片
>

string 底层为 byte 数组

```go
str := "acegjln"

// 字符串与数组之间的转换
arr := []byte(str)	// 按字节切，中文乱码
str = string(arr)

// 字符串与切片之间的转换
slice := []rune(str) // 按uft8编码字符切，中文正常
str = string(slice)

// 向切片追加元素
append(slice, elem)

// 切片的截取，引用传递
slice[:]	// 全部
slice[0:2]

// 值传递
s := copy(slice)
```
注意：
- slice 只支持判断是否为 nil，不支持 ==、!= 判断。
- 字符串底层是 []byte 切片，所以字符串支持slice操作。


#### （3）映射（map）

> map 声明后不会分配内存，需要用 make() 初始化分配内存后才能赋值和使用。
>
> map 中的元素无序，重复键会覆盖。
>
> map 也会动态增加容量。

```go
var map1 map[keytype] valuetype

// 例：
var map1 map[string]string 
map1 = make(map[string]string, 10)
map1["name"] = "YCZ"

map2 := make(map[string]string, 10)

var map3 map[string]string = map[string]string{"key": "value", ..., }

// map 的增删改查 //

// 用 for range 遍历

// map 的删除
delete(map, key)

// 清空map，指向新空间
map1 = make(map[string]string)

// map 查找，若key存在返回true，否则返回false
val, ok := map1["key"]

// map 排序：先将 key 排序，然后按key输出
```

注意：
- 只要是可以做 ==、!= 判断的类型都可以做map的key （数值型、字符串、数组、指针、结构体、接口）。
- 不能做key的类型：slice、map、function。

> map 切片

```go
mapslice := []map[string]string

// 使用 append() 动态添加 map
```

#### （4）管道（channel）

> 管道是线程安全的；
>
> 管道也是有类型的；
>
> channel 默认值为 nil；

```go
// 语法：
var 变量名 chan 数据类型

// 需初始化后使用，不能超过容量
chan1 := make(chan int, 10)

// 插入数据
chan1<- 10

// 取出数据
data := <-chan1

// 有缓冲区的 chan
cy := make(chan int, 10)

// 无缓冲区的 chan
cw := make(chan int)


// 默认，管道是双向的
var chanD chan int

// 只写 chan
var chanW chan<- int 

// 只读 chan
var chanR <-chan int
```

> 管道关闭与管道遍历：
>
> 管道关闭后，只能读，不能写。
>
> 若管道未关闭时遍历管道，会出现 deadlock 错误；
>
> 当管道关闭后，才会正常遍历，遍历完后自动退出。
>
> 利用此特性实现数据通讯。

```go
// 关闭管道
close(chan1)

// 从已关闭管道中，读取最后一个值时，OK 为 false
for {
	if v, ok := <- chan1; ok {
        fmt.Println(v)
    } else {
        fmt.Println("数据读取完毕")
        break;
    }    
}

// 遍历管道，只能用 for-range
for v := range chan1 {
	fmt.Println(v)
}

// 示例 - 当管道关闭后，才会正常遍历，遍历完后自动退出。
package main

import (
	"fmt"
	"sync"
)

var syncChan = make(chan int)
var wg = sync.WaitGroup{}

func main() {
	wg.Add(2)
	go producer(10)
	go consumer()
	wg.Wait()
}

func producer(n int) {
	for i := 1; i <= n; i++ {
		syncChan <- i
	}
	close(syncChan)
	defer wg.Done()
}

func consumer() {
	defer wg.Done()

	// 接收消息直到 chan 关闭
	for v := range syncChan {
		fmt.Println("Consumer:", v)
	}
}

```

注意：

- 向一个空 channel 发送或接收数据，都会阻塞（写阻塞会将该线程挂起）；
- 重复关闭，或关闭一个 <nil channel> （未初始化）的管道将会发生 panic；
- 在操作管道时，写满了继续写或没数据了继续读取，而且没有其它地方处理该管道时，会 deadlock；
- 向一个已关闭的 channel 发送数据，会引起 panic；
- 向一个已关闭的 channel 接收数据，管道为空时，会返回一个零值和FALSE；
- 无缓冲的 channel 是同步的，有缓冲的 channel 是异步的。

### 6、数据类型 - 万能类型

#### （1）`interface{}`

```go
// 空接口，可以接受任何类型
var itf interface{}
```

#### （2）`type Name interface{}`

```go
type 接口名称 interface {
    函数声明
}

// 1 定义接口
type USB interface {
    start()
    stop()
}

// Phone 类
type Phone struct {
	name string
}

// 2 Phone 实现USB接口的所有方法
func (p Phone) start() {
    fmt.Println(p.name, "Start...")
}

func (p Phone) stop() {
    fmt.Println(p.name, "Stop...")
}

// Computer 类
type Computer struct {
	name string
}

// 3 Computer 实现USB的所有方法
func (c Computer) start() {
    fmt.Println(c.name, "Start...")
}

func (c Computer) stop() {
    fmt.Println(c.name, "Stop...")
}

// 使用接口中定义的方法，多态
func working(u USB) {
    
    // 1 带检测的类型断言，不会中断程序
    // 断言获取手机的属性
	if v,ok := u.(Phone); ok {
		fmt.Println("接口类型无法访问属性，必须要断言成原始数据类型：name =", v.name)
	}
    
    // 2 自动断言接口类型
    switch u.(type) {
	case Phone:
		fmt.Println("Phone")
	case Computer:
		fmt.Println("Computer")
	}
    
    u.start()
    u.stop()
}

func main() {
    p := Phone{"手机"}
    working(p)
    
    c := Computer{"电脑"}
    working(c)
}
```

> 内置接口

```go
// 只要实现了 Error() 函数，且返回值为 String 的，都算实现了 error 接口
type error interface { 
	Error() String
}
```

注意：

- 接口中只能有方法的声明，不能有方法的实现。
- 接口中只能有方法不能有属性。
- 只有实现了接口中所有的方法，才算实现了接口。才能用该接口类型接收（如：结构体的值）。
- 接口中也可以嵌套接口类型，继承嵌入接口的所有方法。
- 空接口类型可以接收任意类型的数据。
- 只要是自定义类型，都可以实现接口。
- 接口类型变量可以接收实现了该接口类型的变量，但是只能调用该变量中的方法，不能访问该变量的属性。想要访问变量中的属性，必须将接口类型还原为原始类型（类型断言）。

#### （3）类型断言

> 利用空接口 `interface{}` 是万能类型的特点，系统提供了类型断言功能。
>
> 例如：调用某个类特有的方法时用。
>
> 变量的结构：
>
> `pair<type:"static_type|concrete_type",  value:" ">`

```go
func main() {
    var a interface{}
    var point Point = Point{1, 2}
    a = point
    var b Point
    // b = a 错误
    // 类型断言，将 a 断言为 Point
    b = a.(Point)	
    fmt.Println(b)
    
    // 带检测的类型断言，不会中断程序
    b, ok := a.(Point)
    if ok {
        // 成功
    } else {
        // 失败
    }
}
```

> 利用类型断言处理不同数据类型
>
> v.(type) 自动断言接口值的类型

```go
func TypeJudge(args ... interface{}) {
    for i, v := range args {
        switch v.(type) {
            case bool:
            	fmt.Println("bool 类型")
            case int, int32, int64:
            	fmt.Println("int 类型")
            // ...
            default:
        }
    }
}
```

### 7、流程控制

#### （1）条件语句（if）

```go
if 条件表达式 {
	// ...
} else if 条件表达式 {
	// ...
} else {
	// ...
}
```

#### （2）选择语句（switch）

> Switch 分支默认只执行第一个匹配，后面的语句不再执行，也无需加 break；
>
> 若要继续向下执行，添加 fallthrough。

```go
switch 条件 {
    case 值1:
    	// ...
    case 值2:
    	// ...
    case 值3:
    	// ...
    	fallthrough
    default:
    	// ...
}
```

#### （3）循环语句（for）

```go
// 类似 while(true) 循环
for {
    // 一直循环此操作
}

// 常规 for() 循环
for i := 0; i < 10; i++ {
    // ...
}

// for range 遍历数组、切片、管道、map
for k, v range slice {
    // ...
}
```

#### （4）跳转语句（goto）

```go
goto <tag>
```

#### （5）选择结构（select）

> select 是 Golang 中的一个控制结构，类似于 Switch 语句，用于处理异步 IO 操作。

```go
// 应用场景1：多路监听管道
for {
    select {
        // 尝试从 intChan 读取
        case v := <-intChan:
        	fmt.Println("从intChan读取到数据", v)
        // 尝试从 stringChan 读取
        case v := <-stringChan:
        	fmt.Println("从stringChan读取到数据", v)
        default:
        	fmt.Println("所有管道中都没有数据了")
        	return
    }
}

// 应用场景2：超时处理
package main

import (
	"fmt"
	"runtime"
	"time"
)

func main() {
	channel := make(chan int, 10)
	exitChan := make(chan bool)

	// 生产者闭包
	go func() {
		for i := 1; i <= 10; i++ {
			//fmt.Println("生产：", i)
			channel <- i
		}

		// 这里不能关闭，否则 select 中会一直消费 0 值
		// close(channel)
	}()

	// 消费者闭包
	go func() {
		for {
			select {
			case v := <-channel:
				fmt.Println("消费：", v)
			case <-time.After(time.Second * 5):
				close(exitChan) // 比 exitChan <- true 效率更高

				fmt.Println("程序超时...")
				// 结束该协程
				runtime.Goexit()
			}
		}
	}()

	// 从空队列中读取数据，阻塞，直到队列中有数据
	<-exitChan
}

```

注意：

- 如果有多个 case 可以运行，select 会随机选取一个执行；
- 如果没有可执行的 case 语句，择取执行 default 的语句；
- 如果没有可执行的 case 语句，且没有 default 语句，则会阻塞，直到某个 case 通信可运行；
- select 的 case 后面必须是一个 IO 操作；



### 8、函数

> 参数传递方式：值传递
>
> 值类型：int、float、bool、string、数组、结构体
>
> 引用类型：指针、slice切片、map、管道、接口

```go
func 函数名 (形参列表) (返回值列表) {
	// 执行语句
	return 返回值列表
}
```

在Go语言中，函数参数都是以复制的方式(不支持以引用的方式)传递（比较特殊的是，Go语言闭包函数对外部变量是以引用的方式使用）。

#### （1）mian() 函数

Go 语言程序的默认入口函数（主函数），main() 函数必须在 main 包。

代码执行顺序：（导入包中的 常量 ==> 全局变量 ==> init()）==> 常量 ==> 全局变量 ==> init() ==> main()。

#### （2）init() 函数

- init 函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等；
- 每个包可以拥有多个init函数；
- 包的每个源文件也可以拥有多个init函数；
- 同一个包中多个init函数的执行顺序go语言没有明确的定义(说明)；
- 不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序；
- init函数不能被其他函数调用，而是在main函数执行之前，自动被调用；
- 引入包中的 init 优先级高于本包；

#### （3）不定参数

> args 本质上是一个切片
>

```go
// 支持0到多个参数
func sum(args... int) (sum int) {

}

// 支持1到多个参数
func sum(n1 int, args... int) (sum int) {

}

// 任意类型的任意数量的参数
func sum(args ... interface{}) {
    
}
```

#### （4）多返回值

> 在函数中执行不带任何参数的return语句时，会返回对应的返回值变量的值。

```go
func sqrt(x float64) (ret float64, err error) { 
    if x < 0 { 
        err= errors.New("Should be non-negative numbers!") 
        return 
    }

    return math.Sqrt(x), nil // 支持多重返回值
}
```

#### （5）匿名函数与闭包

匿名函数：没有名字的函数，只调用一次不需要定义名字。

闭包：匿名函数中引用到函数外面的变量，匿名函数与引用到的变量共同构成闭包。

> 递归函数

用函数调用机制理解递归：每次调用函数时，会在【栈区】开辟一个新空间，函数结束栈区回收。

#### （6）内置函数

```go
append()	// 用来追加元素到数组、slice中,返回修改后的数组、slice
close()		// 主要用来关闭channel
delete()	// 从map中删除key对应的value
panic()		// 停止常规的goroutine  （panic和recover：用来做错误处理）
recover()	// 允许程序定义goroutine的panic动作
real()		// 返回complex的实部   （complex、real imag：用于创建和操作复数）
imag()		// 返回complex的虚部
make()		// 用来分配内存，返回Type本身(只能应用于slice, map, channel)
new()		// 用来分配内存，主要用来分配值类型，比如int、struct。返回指向Type的指针
cap()		// capacity是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）
copy()		// 用于复制和连接slice，返回复制的数目
len()		// 来求长度，比如string、array、slice、map、channel ，返回长度
print()
println()	// 底层打印函数，在部署环境中建议使用 fmt 包
```

##### 注：new 与 make 的区别

- make 仅用来分配及初始化类型为 slice、map、chan 的数据；new 可分配任意类型的数据。

- new 分配返回的是指针，即类型 *Type；make 返回类型本身，即 Type。

- new 分配的空间会被清零；make 分配空间后，会进行初始化。

#### （7）defer 延时机制

> 将 defer 后面的语句暂时压入栈中，当函数执行完毕后，再从栈中取出执行（先进后出）。
>
> 类似析构函数，在函数结束后调用。
>
> 常用于：关闭连接资源、加解锁等成对的操作。



### 9、错误处理机制

#### （1）内建接口 error

> 内建 error 接口类型是约定用于表示错误信息，nil值表示无错误。

```go
type error interface {
    Error() string
}
```

#### （2）自定义错误

```go
// errors.New 创建 error 对象
var err1 = errors.New("错误信息1")
// fmt.Errorf 创建 error 对象
var err2 = fmt.Errorf("错误信息2")

// 打印错误信息，不中断程序
fmt.Println(err1, err2)

// 打印错误并中断程序，抛出 panic
panic(err1)
```

#### （3）异常处理

> 通过 defer 和 recover 实现 panic 异常的捕获。打印错误，中断程序，不会抛出 panic。
>
> 注：主线程中无法捕获到 goroutine 中的 panic。

```go
// 使用 defer + recover 捕获和处理异常
// 在 panic 之前定义一个延迟调用函数，用于捕获 panic 异常
defer func() {
	err := recover()
	if err != nil {
		fmt.Println(err)
	}
}()

// 若 defer 中有异常，则只有 defer 中的异常会被捕获
defer func() {
    panic("defer 中的 panic 优先")
}()

// 这里是可能出错的代码
panic("出错了，捕获错误")
```

> 封装 goroutine 方法
>
> 管理野生 goroutine 中的 panic

```go
func Go(g func()) {
	go func() {
		defer func() {
			if exception := recover(); exception != nil {
				fmt.Println(exception)
			}
		}()

		g()
	}()
}
```



### 10、Golang 中嵌套 C

- 在 import "C" 之前注释编写的 C代码；

- 注意  import "C" 和前面注释的 C代码之间不能有空行；

- 在  import "C" 之后编写 Golang 代码；

- 在 Golang 中通过 C.函数名称调用 C代码即可；

```go
package main

/**
#include <stdio.h>

void say()
{
	printf("Hello Golang \n")
}
 */
import "C"

func main() {
	C.say()
}
```

### 11、语法糖

（1）`:=` 赋值符

注意：

- 只能用于局部变量。
- 在函数多返回值，if|for|switch 等语句中定义局部变量非常方便。
- 多变量赋值时，变量可能会重新声明。

（2）`...` 

```go
// 1 作为可变参函数
func Fail(code int, msg string, data ...interface{}) {
	// 
}

// 2 将切片打散传递
a := []int{1, 2, 3}
b := []int{4, 5}
a = append(a, b...) // 将切片打散后追加
```

（3）`_`

`_` 标识符为特殊标识，代表空标识。

- 忽略函数多个返回值时的某个；

- 忽略暂不时用的 import 包。

### 12、包

> 每个包都包含一个 init() 函数，在包导入时被调用。

```go
// 导包时取别名
import (
    _ "fmt"		// 匿名，可以不使用包，但是会执行包的 init()
    t "time"	// 别名
    . "sync"	// 将该包导入到本包，不用 . 语法也可以调用
)
```





## 三、面向对象编程

> public：首字母大写的变量名、常量名、函数名，可以在其它包中访问。
>
> private：首字母小写变量名、常量名、函数名，只能在本包中使用。

### 1、结构体（类）

> 结构体字段在内存中是连续的

```go
// 声明结构体
type ClassName struct {
	Name string
    Age int
    Color String
}

// 创建结构体变量
var obj1 ClassName

var obj2 ClassName = ClassName{
    "Name": "YCZ",
}

var obj3 *ClassName = new(ClassName)
(*obj3).Name
obj3.Name

var obj4 *ClassName = &ClassName{} 

// 结构体标签，JSON序列化的时候，使用tag定义的键
type ClassName struct {
    Name string `json:"name"`
    Age int
    Color String
}

```

### 2、方法

方法：与结构体或接口绑定的函数，让结构体具备某些行为。

> 作用在指定的数据类型上的，自定义数据类型都可以有方法。
>
> 方法与数据类型绑定后，只能通过该数据类型调用。
>
> 注意：方法的传值类型取决于绑定参数中定义的是值类型还是引用类型，而不取决于调用形式。如：(&a).action()，不一定是引用传值。

```go
// 语法
// 如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。
func(接收者 数据类型) 方法名(参数列表) (返回值列表) {
    // 方法体
    return ...
}

// 例：
type Person struct {
	Name string
}

// 为 Person 绑定方法，接收者为值类型
func(p Person) getName() {
	fmt.Println(p.Name)
}

// 为 *Person 绑定方法，接收者为指针类型
// 如果一个类型实现了 String() 方法，在 fmt.Println() 时，默认会调用这个变量的 String() 方法。
func(p *Person) String() string {
	str := fmt.Sprintf("__String: Name=%v", p.Name)
	return str
}

func main() {
    var per Person
    per.Name = "YCZ"
    
    per.getName()
}

func main() {
    per := Person{
		Name: "YCZ",
	}
	// per 调用方法时，会将per也传递给方法
    per.getName()
	fmt.Println(&per)
}
```

### 3、工厂模式

> 当其它包中需要调用首字母小写的结构体时，需要用工厂模式。

### 4、继承

> 如果一个结构体中嵌套了另一个匿名结构体，则该结构体中可以直接访问匿名结构体的所有属性和方法（不分公、私有）。

```go
type Parent struct {
	Name string
	Money float64
}

type Son struct {
    Parent		// 继承结构体 Parent，匿名
    par Parent  // 指定继承结构体名
    Name string
}

fun main() {
    var obj
    // 访问属性、方法
    obj.Name
    obj.action()
    
    // 访问父级属性、方法
    obj.Parent.Name
    obj.Parent.action()
    
    obj.par.Name
    
}
```

### 5、接口（实现多态）

> `interface{}` 空接口为万能类型
>
> 接口中不能存在变量
>
> 接口中的方法不能有方法体（抽象方法）
>
> 实现接口，就是实现接口的所有方法，并可以实现多个接口
>
> 实现了接口的自定义变量可以赋值给接口变量
>
> 接口之间也可以继承
>
> 多态参数：接口的方法可以接收不同类型的结构体变量
>
> 多态数组：接口数组中可以存放不同类型的结构体变量

```go
package main

import "fmt"

// 定义接口
type Member interface {
	// 声明两个抽象方法
	Start()
	Stop()
}

/**
 * Student 结构体
 * 结构体 Student 实现了接口的所有方法
 * 即 结构体 Student 实现了接口
 */
type Student struct {

}

func(stu Student) Start() {
	fmt.Println("Student->Start()")
}

func(stu Student) Stop() {
	fmt.Println("Student->Stop()")
}

// Teacher 结构体
type Teacher struct {

}

func(tea Teacher) Start() {
	fmt.Println("Teacher->Start()")
}

func(tea Teacher) Stop() {
	fmt.Println("Teacher->Stop()")
}


// 学校结构体
type School struct {

}

// 学校绑定方法的参数为接口类型的变量
func (s School) Working(m Member) {
	// 实现了接口的变量调用对应的方法
	m.Start()
	m.Stop()
}

func main() {
	student := Student{}
	teacher := Teacher{}

	school := School{}

	school.Working(student)
	school.Working(teacher)
}
```

### 6、利用 sort.Sort 自定义排序

```go
package main

import (
	"fmt"
	"math/rand"
	"sort"
)

// 定义学生结构体
type Student struct {
	Name  string
	Age   string
	Score int
}

func (s Student) String() string {
	return fmt.Sprintf("姓名：%s \t 分数：%d \n", s.Name, s.Score)
}

// 声明 Student 结构体的切片类型
type StudentSlice []Student

// Student 结构体的切片实现 Interface 接口
func (ss StudentSlice) Len() int {
	return len(ss)
}

// 排序规则
func (ss StudentSlice) Less(i, j int) bool {
	return ss[i].Score > ss[j].Score
}

// 交换下标 i,j 的值
func (ss StudentSlice) Swap(i, j int) {
	ss[i], ss[j] = ss[j], ss[i]
}

func main() {
	var students StudentSlice
	for i := 0; i < 10; i++ {
		stu := Student {
			Name:  fmt.Sprintf("name-%d", rand.Intn(100)),
			Score: rand.Intn(100),
		}
		students = append(students, stu)
	}

	fmt.Println(students)
	sort.Sort(students)
	fmt.Println("========== 按分数排序 ==========")
	fmt.Println(students)
}
```



## 四、并发编程

### 1、并发基础

串行：同一时刻，只有一条指令在一个CPU上执行，其他指令需等待前一条执行完毕后再执行。

并行：同一时刻，多条指令在多个CPU上执行。（多线程、多核）

并发：伪并行，同一时刻，只能有一条指令在一个CPU上执行，但CPU会快速的在多条指令之间轮询执行。（多线程、单核）

程序：为实现某功能编写的代码，通过编译之后生成的可执行文件。

进程：是指程序在操作系统中的一次执行过程，是系统进行资源分配的基本单元。并且多个进程之间的空间是独立的。

### 2、Go 并发编程（goroutine）

```go
// 启动 goroutine
go func () {
    println("hello go routine")
}()

// 示例 - 不会有任何输出
package main

import (
	"fmt"
	"time"
)

func Add(x, y int) {
    /*if x > 5 || y > 5 {
    	// 任何 goroutine 中出现 panic，都会导致整个程序崩溃
		panic("too big!")
	}*/
	fmt.Println(x + y)
}

func main() {
	for i := 0; i < 10; i++ {
		go Add(i, i)
	}
	// 苦等 1s（缺乏通信机制）后，输出结果并非有序（goroutine 的执行无序）
	// time.Sleep(time.Second)
}

/**
 * 问题剖析：
 - 当 main() 函数结束时，主线程退出，其并不会等待其他 goroutine（非主线程）结束。
 - 调度器不能保证多个 goroutine 执行次序。
 - 任何 goroutine 中 panic，都会导致系统崩溃（可用错误捕获机制解决）。
 - 主进程与协程之间缺乏通信机制，并可能存在资源抢占问题。（用 `go run -race test.go` 查看资源竞争情况）
 - 需要注意的是，如果 goroutine 中的函数有返回值，那么这个返回值会被丢弃。
 */
```

### 3、并发通信

> 推荐使用消息传递而不是共享内存来进行并发编程（面向消息编程）。

#### （1）资源竞争案例

```go
package main

import (
	"fmt"
)

var (
	// 存储阶乘的 Map
	factMap = make(map[int]int, 10)
)

func main() {
	for i := 1; i <= 10; i++ {
		go SetFact(i)
		go GetFact(i)
	}
}

// 设置阶乘
func SetFact(n int) {
	res := 1
	for i := 1; i <= n; i++ {
		res *= i
	}
    factMap[n] = res
}

// 获取阶乘
func GetFact(n int) {
	fmt.Printf("Factorial(%d) = %d \n", n, factMap[n])
}
```

> 分析竞争：

```shell
# -race 选项查看资源竞争情况
> go run -race main.go
==================
# 数据竞争1：写写竞争
WARNING: DATA RACE
# goroutine-8 在 <0x00c00006e3c0> 处写入
Write at 0x00c00006e3c0 by goroutine 8:
  runtime.mapassign_fast64()
      D:/Go-16/src/runtime/map_fast64.go:92 +0x0
  main.Factorial()
      F:/GoProject/myProject/public/main.go:28 +0x91

# goroutine-7 上一次在 <0x00c00006e3c0> 写入：
Previous write at 0x00c00006e3c0 by goroutine 7:
  runtime.mapassign_fast64()
      D:/Go-16/src/runtime/map_fast64.go:92 +0x0
  main.Factorial()
      F:/GoProject/myProject/public/main.go:28 +0x91

# goroutine-8（运行中）、 goroutine-7（已完成）都创建于 main()
Goroutine 8 (running) created at:
  main.main()
      F:/GoProject/myProject/public/main.go:13 +0x7a

Goroutine 7 (finished) created at:
  main.main()
      F:/GoProject/myProject/public/main.go:13 +0x7a
==================
==================
# 数据竞争2：读写竞争
WARNING: DATA RACE
# 主线程在 <0x00c000082168> 处读取
Read at 0x00c000082168 by main goroutine:
  main.main()
      F:/GoProject/myProject/public/main.go:17 +0x12c

# goroutine-7 上一次在 <0x00c000082168> 写入：
Previous write at 0x00c000082168 by goroutine 7:
  main.Factorial()
      F:/GoProject/myProject/public/main.go:28 +0xa6

# goroutine-7（已完成）创建于 main()
Goroutine 7 (finished) created at:
  main.main()
      F:/GoProject/myProject/public/main.go:13 +0x7a
==================
Factorial(1) = 1
Factorial(4) = 24
Factorial(5) = 120
Factorial(7) = 5040
Factorial(8) = 40320
Factorial(2) = 2
Factorial(3) = 6
Factorial(6) = 720
Factorial(9) = 362880
Factorial(10) = 3628800
# 发现2个数据竞争
Found 2 data race(s)
exit status 66
```

#### （1）共享内存通信（不推荐）

- sync.Mutex

```go
package main

import (
	"fmt"
	"sync"
)

var (
	// 存储阶乘的 Map
	factMap = make(map[int]int, 10)
	// 声明一个全局的互斥锁 lock
	lock = sync.Mutex{}
)

func main() {
	for i := 1; i <= 10; i++ {
		go SetFact(i)
		go GetFact(i)
	}
}

// 设置阶乘
func SetFact(n int) {
	res := 1
	for i := 1; i <= n; i++ {
		res *= i
	}

	// 加锁
	lock.Lock()

	// ------------------ 临界区 ------------------ //
	factMap[n] = res
	// ------------------ 临界区 ------------------ //

	// 解锁
	lock.Unlock()
}

// 获取阶乘
func GetFact(n int) {
	// 加锁
	lock.Lock()

	// ------------------ 临界区 ------------------ //
	fmt.Printf("Factorial(%d) = %d \n", n, factMap[n])
	// ------------------ 临界区 ------------------ //

	// 解锁
	lock.Unlock()
}
```

- sync.RWMutex

```go
package main

import (
	"fmt"
	"sync"
)

var (
	// 存储阶乘的 Map
	factMap = make(map[int]int, 10)
	// 声明一个全局的读写互斥锁 lock
	lock = sync.RWMutex{}
)

func main() {
	for i := 1; i <= 10; i++ {
		go SetFact(i)
		go GetFact(i)
	}
}

// 设置阶乘
func SetFact(n int) {
	res := 1
	for i := 1; i <= n; i++ {
		res *= i
	}

	// 加写锁
	lock.Lock()

	// ------------------ 临界区 ------------------ //
	factMap[n] = res
	// ------------------ 临界区 ------------------ //

	// 解写锁
	lock.Unlock()
}

// 获取阶乘
func GetFact(n int) {
	// 加读锁
	lock.RLock()

	// ------------------ 临界区 ------------------ //
	fmt.Printf("Factorial(%d) = %d \n", n, factMap[n])
	// ------------------ 临界区 ------------------ //

	// 解读锁
	lock.RUnlock()
}
```

虽然用同步锁机制解决数据竞争的问题，但线程间的通信还是存在问题。因写进程还未写入数据，读进程就去读而读到数据的零值。

#### （2）消息传递通信（chan）

```go
package main

import "fmt"

func writeData(chanInt chan int) {
	for i := 1; i <= 200; i++ {
		chanInt <- i
		fmt.Println("入队：", i)
	}

	// 写完数据后，关闭队列
	close(chanInt)
}

func readData(chanInt chan int, chanExit chan bool) {
	for v := range chanInt {
		fmt.Println("读取数据：", v)
	}

	// 读完数据后，向退出管道添加标识，并关闭管道
	chanExit <- true
	close(chanExit)
}

func main() {
    // 容量 100 < 最大可能长度 200
	channelInt := make(chan int, 100)
	channelExit := make(chan bool, 1)

	go writeData(channelInt)
	go readData(channelInt, channelExit)

	// 直到从已关闭的退出管道中读取到最后一个值时，才退出主线程
	for {
		_, ok := <-channelExit
		if ok == false {
			break
		}
	}
}
```



### 4、并发工具包

#### （1）runtime 包

```go
// 返回本地机器的逻辑CPU个数
runtime.NumCPU()

// 设置可同时执行的最大CPU数
runtime.GOMAXPROCS(3)

// 退出协程
// Goexit 终止调用它的go程。其它go程不会受影响。
// Goexit 会在终止该go程前执行所有defer的函数。
// 在 main() 中，会等待其它 goroutine 执行完后崩溃（deadlock）。
// 注：os.Exit() 可终止进程，但不会执行延迟调用。
runtime.Goexit()

// 强制调度器切换 goroutine
runetime.Gosched()
```

> 示例

```go
/**
 * sing() 与 dance() 交替执行。
 * sing() 在输出5次后结束该协程，并输出 sing finish。
 * dance() 继续执行，完成10次输出后 finish。
 */
package main

import (
    "fmt"
	"runtime"
	"sync"
)

func sing() {
	defer func() {
		fmt.Println("sing finish...")
		// 通知 wg 协程结束
		wg.Done()
	}()

	for i := 0; i < 10; i++ {
		fmt.Println("sing...")
		// Gosched使当前go程放弃处理器，以让其它go程运行。
		// 它不会挂起当前go程，因此当前go程未来会恢复执行。
		runtime.Gosched()
		if i == 4 {
			// Goexit 终止调用它的go程。其它go程不会受影响。
			// Goexit 会在终止该go程前执行所有defer的函数。
			runtime.Goexit()
		}
	}
}

func dance() {
	defer func() {
		fmt.Println("dance finish...")
		// 线程结束后，减少 WaitGroup 计数器的值。
		wg.Done()
	}()

	for i := 0; i < 10; i++ {
		fmt.Println("dance...")
		// 暂时放弃处理
		runtime.Gosched()
	}
}

/**
 * WaitGroup 用于等待一组线程的结束。
 * 父线程调用 Add() 方法来设定应等待的线程的数量。
 * 每个被等待的线程在结束时应调用 Done() 方法。
 * 同时，主线程里可以调用 Wait() 方法阻塞至所有线程结束。
 */
var wg = sync.WaitGroup

func main() {
    // Add() 设置等待线程数，本方法应在创建新的线程或者其他应等待的事件之前调用。
	wg.Add(2)
	// 开启协程
	go sing()
	go dance()
    // Wait() 阻塞直到 WaitGroup 计数器减为0
	wg.Wait()
}
```



#### （2）sync 包

> sync 包提供了基本的同步基元，如互斥锁。除了 Once 和 WaitGroup 类型，大部分都是适用于低水平程序线程，高水平的同步使用 channel 通信更好一些。 

> Once

```go
var once sync.Once

for i := 0; i < 10; i++ {
    // Do()方法可以保证在全局范围内只调用指定的函数一次。
    // 而且所有其他goroutine在调用到此语句时，将会先被阻塞，直至全局唯一的once.Do()调用结束后才继续。
    once.Do(func() {
        fmt.Println("Only once")
    })
}
```

> Mutex 互斥锁

```go
/**
 * Mutex 是一个互斥锁，可以创建为其他结构体的字段；零值为解锁状态。
 * Mutex 类型的锁和线程无关，可以由不同的线程加锁和解锁。
 */
var lock sync.Mutex

// Lock() 加锁，如果lock已经加锁，则阻塞直到lock解锁
lock.Lock()
// Unlock() 解锁，对未加锁的 lock.Unlock() 会导致运行时错误。
lock.Unlock()
```

> RWMutex 读写互斥锁

```go
/**
 * RWMutex 是读写互斥锁。该锁可以被同时多个读取者持有或唯一个写入者持有。
 * 可以创建为其他结构体的字段；零值为解锁状态。
 * RWMutex 类型的锁也和线程无关，可以由不同的线程加读取锁/写入和解读取锁/写入锁。
 */
var rwLock sync.RWMutex

// 加写锁，其它线程禁止读、写，适用于 安全设置
rwLock.Lock()
// 解除写锁，对未加锁的 rw.Unlock() 会导致运行时错误。
rwLock.Unlock()

// 加读锁，其它线程只读，适用于 安全读取
rwLock.RLock()
// 解除读锁，对未加锁的 rw.Unlock() 会导致运行时错误。
rwLock.RUnlock()

// 返回一个互斥锁
rwLock.RLocker()
```

> Cond

```

```

> WaitGroup

```go
/**
 * WaitGroup 用于等待一组线程的结束。
 * 父线程调用 Add() 方法来设定应等待的线程的数量。
 * 每个被等待的线程在结束时应调用 Done() 方法。
 * 同时，主线程里可以调用 Wait() 方法阻塞至所有线程结束。
 */
var wg = sync.WaitGroup

// Add() 设置等待线程数，本方法应在创建新的线程或者其他应等待的事件之前调用。
wg.Add(2)
// 线程结束后，减少 WaitGroup 计数器的值。
defer wg.Done()
// Wait() 阻塞直到 WaitGroup 计数器减为0
wg.Wait()
```

> Pool

```

```

#### （3）MPG 模式

M（machine）：系统级线程；

P（processor）：调度器，可以承载若干个 G，且能够使这些 G 适时地与 M 进行对接，并提供 G 执行所需的上下文；

G（goroutine）：用户级线程 => 协程；

### 5、控制 Goroutine 的数量

> 应用：避免 MySQL: 1040 Too many connections. 错误

```go
// 最大 Goroutine 数量
maxG := make(chan struct{}, 400)

wg := sync.WaitGroup{}
wg.Add(len(works))

// 遍历任务
for _, w := range works {
    // 每个任务开一个协程
    go func() {
        // 释放
        defer func() {
            wg.Done()
            // 运行完成，退位
            <-maxG
        }

        // 开始运行，占位
        maxG <- struct{}{}
        
        // 开始任务...
    }()
}

wg.Wait()
```



## 五、网络编程

### 1、Socket 编程（net）

传统 Socket 编程步骤：

(1) 建立Socket：使用socket()函数。 

(2) 绑定Socket：使用bind()函数。 

(3) 监听：使用listen()函数。客户端连接：使用connect()函数。 

(4) 接受连接：使用accept()函数。 

(5) 接收：使用receive()函数。客户端发送：使用send()函数。

#### （1）Conn 接口

```go
type Conn interface {
    // Read从连接中读取数据
    // Read方法可能会在超过某个固定时间限制后超时返回错误，该错误的Timeout()方法返回真
    Read(b []byte) (n int, err error)
    // Write从连接中写入数据
    // Write方法可能会在超过某个固定时间限制后超时返回错误，该错误的Timeout()方法返回真
    Write(b []byte) (n int, err error)
    // Close方法关闭该连接
    // 并会导致任何阻塞中的Read或Write方法不再阻塞并返回错误
    Close() error
    // 返回本地网络地址
    LocalAddr() Addr
    // 返回远端网络地址
    RemoteAddr() Addr
    // 设定该连接的读写deadline，等价于同时调用SetReadDeadline和SetWriteDeadline
    // deadline是一个绝对时间，超过该时间后I/O操作就会直接因超时失败返回而不会阻塞
    // deadline对之后的所有I/O操作都起效，而不仅仅是下一次的读或写操作
    // 参数t为零值表示不设置期限
    SetDeadline(t time.Time) error
    // 设定该连接的读操作deadline，参数t为零值表示不设置期限
    SetReadDeadline(t time.Time) error
    // 设定该连接的写操作deadline，参数t为零值表示不设置期限
    // 即使写入超时，返回值n也可能>0，说明成功写入了部分数据
    SetWriteDeadline(t time.Time) error
}

/**
 * func Dial(network, address string) (Conn, error)
 * 在网络 network 上连接地址 address，并返回一个 Conn 接口。
 * 可用的 network：tcp（IPv4 or IPv6）, tcp4, tcp6, udp（IPv4 or IPv6）, udp4, udp6, ip（IPv4 or IPv6）, ip4, ip6, unix, unixgram, unixpacket.
 */
conn, err := net.Dial("tcp", ":8080")

/**
 * func DialTimeout(network, address string, timeout time.Duration) (Conn, error)
 * DialTimeout类似Dial但采用了超时。timeout参数如果必要可包含名称解析。
 */

// 实际上，Dial() 函数是对 DialTCP()、DialUDP()、DialIP()、DialUnix() 的封装。
// 使用 DialTCP() 与 Dial() 效果一样。
tcpAddr, err := net.ResolveTCPAddr("tcp", "www.baidu.com:80")
tcpConn, err := net.DialTCP("tcp", nil, tcpAddr)
```

#### （2）TCP

> 服务端：
>

```go
package main

import (
	"fmt"
	"net"
)

func response(conn net.Conn) {
	// 这个切片用于接收消息
	msg := make([]byte, 1024)
	// 从连接中获取消息，未获取到消息时，阻塞
	n, err := conn.Read(msg)
	if err != nil {
		fmt.Println("获取出错：", err)
		return
	}
	fmt.Println("接收到消息：", string(msg[:n]))

	// 处理完后关闭连接
	defer conn.Close()
}

// 监听端口
// 接收客户端的连接请求
// 处理客户端的请求（goroutine）
func main() {
	fmt.Println("服务器开启监听...")

	// Listen 监听本地网络地址上的广播（network 只能为：tcp、tcp4、tcp6、unix）
	listener, err := net.Listen("tcp", "0.0.0.0:1027")
	if err != nil {
		fmt.Println("监听失败：", err)
		return
	}

	// 关闭本次监听
	defer listener.Close()

	// Addr 返回监听的网络地址
	fmt.Println("监听地址为：", listener.Addr())

	// 循环等待连接
	for {
		fmt.Println("等待客户端连接...")
		// Accept 等待并返回下一个连接
		conn, err := listener.Accept()
		if err != nil {
			fmt.Println("连接失败：", err)
		} else {
			fmt.Println("本机地址：", conn.LocalAddr())
			fmt.Println("请求地址：", conn.RemoteAddr())
			// 用协程响应各个请求
			go response(conn)
		}
	}
}
```

> 客户端：
>

```go
package main

import (
	"fmt"
	"net"
)

// 建立连接
// 发送请求
// 关闭连接
func main() {
	conn, err := net.Dial("tcp", ":1027")
	if err != nil {
		fmt.Println("连接出错：", err)
	}

	msg := "消息 hhh"

	// 往连接中发送消息
	n, err := conn.Write([]byte(msg))
	if err != nil {
		fmt.Println("发送出错：", err)
	}
	fmt.Println("发送字节：", n)
    
    defer conn.Close()
}
```

#### （3）IP

```go
type IP []byte

// ParseIP将s解析为IP地址，并返回该地址。如果s不是合法的IP地址文本表示，ParseIP会返回nil。
ip := net.ParseIP("127.0.0.1")
// 返回IP地址ip的默认子网掩码。只有IPv4有默认子网掩码；如果ip不是合法的IPv4地址，会返回nil。
ipMask := ip.DefaultMask()

// IPv4Mask返回一个4字节格式的IPv4掩码a.b.c.d。
ipMask := net.IPv4Mask(255, 255, 255, 255)

// 根据域名查找 IP，net 必须是 ip、ip4、ip6。
ipAddr, err := net.ResolveIPAddr("ip", "www.baidu.com")
addrs, err := net.LookupHost("www.baidu.com")
```

### 2、HTTP 编程（net/http）

> 一个最简单的 HTTP 服务器

```go
package main

import (
	"fmt"
	"net/http"
)

/**
 * 一个最简单的 HTTP 服务器
 * 仅使用内置包 net/http 函数
 */
func main() {
	/**
	 * 注册路由与处理函数的绑定（默认注册到 DefaultServeMux）
	 * patter string 路由模式
	 * handler func 处理函数
	 */
	http.HandleFunc("/ping", func(writer http.ResponseWriter, request *http.Request) {
		fmt.Fprintln(writer, "pong")
	})
	
	/**
	 * 监听并启动服务
	 * addr string 监听TCP地址
	 * handler Handler 处理器ServeMux，handler参数一般会设为nil，此时会使用DefaultServeMux。
	 */
	http.ListenAndServe(":9988", nil)
}
```

```go
/**
 * Handler 接口
 * 任何结构，只要实现了ServeHTTP方法，这个结构就可以称之为Handler对象。
 * 实现了Handler接口的对象可以注册到HTTP服务端，为特定的路径及其子树提供服务。
 * ServeMux 会使用Handler并调用其ServeHTTP方法处理请求并返回响应。
 */
type Handler interface {
	ServerHTTP(ResponseWrite, *Request)
}

/**
 * HandlerFunc 是一个适配器，实现了 Handler 接口
 * 通过类型转换让我们可以将普通的函数作为HTTP处理器使用。
 * 如果f是一个具有适当签名的函数，HandlerFunc(f)通过调用f实现了Handler接口。
 */
type HandlerFunc func(ResponseWriter, *Request)

// HandlerFunc.ServeHTTP 方法会调用 f(w, r)
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
	f(w, r)
}

/**
 * ServeMux 是HTTP请求的多路转接器。实现了 Handler 接口
 * 它会将请求URL与注册模式的列表进行匹配，并调用模式的处理器处理请求。
 */
type ServeMux struct {
	mu sync.RWMutex
	// pattern和handler的路由注册 map
	m     map[string]muxEntry
	hosts bool
}

type muxEntry struct {
	explicit bool
	h        Handler
	pattern  string
}

// ServeMux.HandlerFun 同名方法：注册一个处理器函数handler和对应的模式pattern
func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	if handler == nil {
		panic("http: nil handler")
	}
	// 将传入参数handler转换为 HandlerFunc 适配器
	mux.Handle(pattern, HandlerFunc(handler))
}

// ServeMux.ServeHTTP 将请求派遣到与请求的URL最匹配的模式对应的处理器
func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {
	if r.RequestURI == "*" {
		if r.ProtoAtLeast(1, 1) {
			w.Header().Set("Connection", "close")
		}
		w.WriteHeader(StatusBadRequest)
		return
	}
	h, _ := mux.Handler(r)
	h.ServeHTTP(w, r)
}
```

- 获取请求参数

```go
package main

import (
	"fmt"
	"net/http"
)

func sayHello(w http.ResponseWriter, r *http.Request) {
	// 解析URL中的查询字符串，并将解析结果更新到 r.Form 字段
	// 对于POST或PUT请求，ParseForm还会将body当作表单解析，并将结果既更新到r.PostForm也更新到r.Form。
	// 并且对于同名变量 POST或PUT请求主体要优先于URL查询字符串
	//r.ParseForm()

	// 将请求的主体作为 multipart/form-data 解析，
	// 得到的文件记录最多 maxMemory 字节保存在内存，其余部分保存在硬盘的temp文件里
	// 如果必要，ParseMultipartForm会自行调用ParseForm
	//r.ParseMultipartForm(1024*1024)

	// 返回 r.Form[key] 切片的第一个值，本函数会隐式调用 ParseMultipartForm和ParseForm
	name := r.FormValue("name")
	// 返回 r.PostForm[key] 切片的第一个值，本函数会隐式调用 ParseMultipartForm和ParseForm
	age := r.PostFormValue("age")
	// 返回 r.MultipartForm[key] 切片的第一个文件和他的信息，本函数会隐式调用 ParseMultipartForm和ParseForm
	// 查询失败会返回ErrMissingFile错误。
	// file, filehead, err := r.FormFile("file")

	// 写入响应
	fmt.Fprintf(w, "hello %s, age %s \n", name, age)
}

func main() {
    // 注册路由
	http.HandleFunc("/hello", sayHello)

	fmt.Println("开启服务...")
	http.ListenAndServe(":8080", nil)
}
```

- 会话操作 Cookie & Session

```
// 设置 Cookie
expiration := *time.LocalTime()
expiration.Year += 1
cookie := http.Cookie{Name: "username", Value: "astaxie", Expires: expiration}
http.SetCookie(w, &cookie)

// 读取 Cookie
cookie, _ := r.Cookie("username")
// 循环读取
for _, cookie := range r.Cookies() {
 fmt.Fprint(w, cookie.Name)
}
```

### 3、RPC 编程（net/rpc）

> RPC（远程过程调用）工作原理

运行时，一次客户机对服务器的 RPC 调用，其内部操作大致有如下十步：

- 调用客户端句柄；执行传送参数 

- 调用本地系统内核发送网络消息 

- 消息传送到远程主机 

- 服务器句柄得到消息并取得参数 

- 执行远程过程 

- 执行的过程将结果返回服务器句柄 

- 服务器句柄返回结果，调用远程系统内核 

- 消息传回本地主机 

- 客户句柄由内核接收消息 

- 客户接收句柄返回的数据

> Go 的 rpc 默认使用 encoding/gob 编码格式传递数据。
>
> 用 net/rpc/jsonrpc 包下的相关方法，使用 JSON 数据格式传递。

只有满足如下标准的方法才能用于远程访问，其余方法会被忽略：

```
- 方法是导出的（首字母大写）
- 方法有两个参数，都是导出类型或内建类型
- 方法的第二个参数是指针（输出参数）
- 方法只有一个error接口类型的返回值

func (t *T) MethodName(argType T1, replyType *T2) error
```

> rpcServer.go

```go
package main

import (
	"fmt"
	"net"
	"net/rpc"
)

type Welcome struct {
}

func (this *Welcome) Hello(name string, res *string) error {
	*res = "Hello " + name
	return nil
}

func main() {
	// 注册 RPC 服务，绑定对象的方法
	err := rpc.RegisterName("welcome", new(Welcome))
	if err != nil {
		fmt.Println("PRC 注册失败：", err)
		return
	}

	// 设置监听
	listen, err := net.Listen("tcp", "127.0.0.1:8881")
	if err != nil {
		fmt.Println("监听失败：", err)
		return
	}
	defer listen.Close()

	fmt.Println("开始监听 ...")

	// 接收请求
	conn, err := listen.Accept()
	if err != nil {
		fmt.Println("连接失败：", err)
		return
	}
	defer conn.Close()

	fmt.Println("连接成功 ...")

	// 绑定服务
	rpc.ServeConn(conn)
}
```

> rpcClient.go

```go
package main

import (
	"fmt"
	"net/rpc"
)

func main() {
	// 用 RPC 连接服务器
	client, err := rpc.Dial("tcp", "127.0.0.1:8881")
	if err != nil {
		fmt.Println("连接服务器出错：", err)
		return
	}
	defer client.Close()

	// 调用远程函数
	var res string
	err = client.Call("welcome.Hello", "YCZ", &res)
	if err != nil {
		fmt.Println("远程函数调用出错：", err)
		return
	}
    
	fmt.Println("res：", res)
}
```



### 4、JSON 编码（encoding/json）

```go
package main

import (
	"encoding/json"
	"fmt"
)

/**
 * 只有可导出（首字母大写）结构体成员才会被编码，name 会被忽略
 * omitempty 选项表示结构体成员为空或零值时不编码该成员
 */
type Student struct {
	StuId int `json:"stu_id"`
	name  string
	Score float32 `json:"score,omitempty"`
}

func main() {
	students := []Student{
		{
			StuId: 1001,
			name:  "YCZ",
			Score: 100,
		},
		{
			StuId: 1002,
			name:  "JYM",
			Score: 98,
		},
		{
			StuId: 1003,
			name:  "YYY",
			Score: 0,
		},
	}

	// json 编码
	jsonEncode1, err := json.Marshal(students)
	if err != nil {
		fmt.Println("[JSON ENCODING ERROR]", err)
		return
	}

	// json 编码并缩进
	jsonEncode2, err := json.MarshalIndent(students, "", "  ")
	if err != nil {
		fmt.Println("[JSON ENCODING ERROR]", err)
		return
	}

	fmt.Printf("%s\n", jsonEncode1)
	fmt.Printf("%s\n", jsonEncode2)

	// json 解码
	var jsonDecode []Student

	err = json.Unmarshal(jsonEncode1, &jsonDecode)
	if err != nil {
		fmt.Println("[JSON DECODING ERROR]", err)
		return
	}

	fmt.Println(jsonDecode)
}
```



### 5、net/url

> url 包解析 URL 并实现了查询的译码。

```go
package main

import (
	"fmt"
	"net/url"
)

/**
 * URL基本格式如下：
 * <scheme>://[<user>:<password>@]<host>:<port>/<path>[?<query>][#fragment]
 */
// URL类型代表一个解析后的URL
type URL struct {
	Scheme     string    // 协议，如：http、https
	Opaque     string    // 编码后的不透明数据
	User       *Userinfo // 用户名和密码信息，比如FTP需要传入明文的用户名和密码来获取资源
	Host       string    // host 或 host:port
	Path       string    // 路径，使用 / 分隔
	RawPath    string    // 已编码的路径提示
	ForceQuery bool      // 添加一个查询（?），即使 RawQuery 为空
	RawQuery   string    // 编码后的查询字符串，没有'?'
	Fragment   string    // 引用的片段（文档位置），没有'#'
}

type Userinfo struct {
	username    string
	password    string
	passwordSet bool
}

/**
 * Values 将键映射到值的列表。
 * 它一般用于查询的参数和表单的属性。
 */
type Values map[string][]string

func main() {
	getUrl()
	getUserinfo()
	getValue()
}

func getUrl() {
	// URL 字符串 的编码 & 解码
	url_encode := url.QueryEscape("name=ycz&age=18")
	url_decode, _ := url.QueryUnescape(url_encode)
	fmt.Println(url_encode)
	fmt.Println(url_decode)

	// 解析rawurl为一个URL结构体，rawurl可以是绝对地址，也可以是相对地址。
	url, err := url.Parse("https://studygolang.com/pkgdoc?query=test")
	// 解析rawurl为一个URL结构体，该函数假设参数为绝对路径，并会假设该 URL 没有 #fragment 后缀
	//url, err := url.ParseRequestURI("https://studygolang.com/pkgdoc?query=test")

	if err != nil {
		fmt.Println("Parse() Error:", err)
	} else {
		fmt.Println("Schema:", url.Scheme)
		fmt.Println("Host:", url.Host)
		fmt.Println("Port:", url.Port())
		fmt.Println("Path:", url.Path)
		fmt.Println("Query:", url.Query())
	}

	// 判断 URL 是否为绝对路径
	fmt.Println("IsAbs():", url.IsAbs())
	// 解析RawQuery字段并返回其表示的Values类型键值对
	fmt.Println("Query():", url.Query())
	// 返回编码好的 path?query 或 opaque?query 字符串，用在HTTP请求里
	fmt.Println("RequestURI():", url.RequestURI())
	// 将URL重构为一个合法URL字符串
	fmt.Println("URL():", url.String())
	// 以u为上下文来解析一个URL，ref可以是绝对或相对URL
	url2, err := url.Parse("./doc?key=1")
	if err != nil {
		fmt.Println("URL.Parse() Error:", err)
	} else {
		fmt.Println("URL2():", url2.String())
	}
	// 根据一个绝对URI将一个URI补全为一个绝对URI
	ref, err := url.Parse("./doc?key=2")
	abs_url := url.ResolveReference(ref)
	fmt.Println("ABS_URL():", abs_url.String())
}

func getUserinfo() {
	// 返回一个设置username，无密码的 *Userinfo
	userinfo := url.User("YCZ")
	// 返回一个设置username、password的 *Userinfo
	userinfo = url.UserPassword("YCZ", "123")

	username := userinfo.Username()
	// 如果设置了密码返回密码和真，否则会返回假
	password, _ := userinfo.Password()
	fmt.Printf("userinfo username=%s, password=%s \n", username, password)
	// 返回编码后的用户信息，格式为"username[:password]"
	fmt.Println("userinfo.String():", userinfo.String())
}

func getValue() {
	values, _ := url.ParseQuery("name=ycz&age=18")
	// 获取key对应的值集的第一个值
	fmt.Println("v.Get(): name=", values.Get("name"))
	// 将key对应的值集设为只有value，它会替换掉已有的值集。
	values.Set("score", "90")
	// 将value添加到key关联的值集里原有的值的后面
	values.Add("score", "91")
	// 删除key关联的值集
	values.Del("aa")

	fmt.Printf("vaules: %#v \n", values)
}
```



## 十、GO 标准库

### 1、格式化输入输出（fmt）

#### （1）获取控制台输入

```go
var name string
var age int

# 按行扫描输入，在换行时停止扫描
fmt.Println("请输入姓名")
fmt.Scanln(&name)
fmt.Println("请输入年龄")
fmt.Scanln(&age)
fmt.Printf("name: %s \t age： %d \n", name, age)

# 按格式扫描输入，在换行时停止扫描
fmt.Println("请输入姓名\t年龄：")
fmt.Scanf("%s %d", &name, &age)
fmt.Printf("name: %s \t age： %d \n", name, age)
```



### 2、文件操作（os）

#### （1）File 对象

> 获取文件对象

```go 
type File struct {
    // 内含隐藏或非导出字段
}

// 新建文件
file, err := os.Create("text.txt")
file := os.NewFile(0, "text.txt")
// 打开文件
file, err := os.Open("text.txt")
file, err := os.OpenFile("text.txt", os.O_APPEND, 0)
// 关闭文件
err := file.Close()

// 获取文件名
file_name = file.Name()
// 获取文件对象描述符
file_info, err = file.Stat()
// 修改文件模式
err = file.Chmod(0777)
// 修改文件用户ID及组ID
err = file.Chown(uid, gid)
/**
 * 设置下一次读/写的位置。
 * offset为相对偏移量，
 * whence决定相对位置：0为相对文件开头，1为相对当前位置，2为相对文件结尾。
 * 它返回新的偏移量（相对开头）和可能的错误。
 */
ret, err = file.Seek(offset, whence)

func getFile(filename string) *os.File {
	/**
	 * os.Create()
	 * 采用模式 0666（任何人都可读写，不可执行）创建文件
	 * 若文件已存在，则清空文件
	 * 对应 O_RDWR 模式
	 */
	/*file, err := os.Create(filename)
	if err != nil {
		fmt.Println("[Create File Error] ", err)
	}*/

	/**
	 * os.NewFile()
	 * 使用给出的Unix文件描述符和名称创建一个文件
	 */
	// file := os.NewFile(0, filename)

	/**
	 * os.Open()
	 * 打开一个文件仅用于读取
	 * 对应 O_RDONLY 模式
	 */
	/*file, err := os.Open(filename)
	if err != nil {
		fmt.Println("[Open File Error] ", err)
	}*/

	/**
	 * os.OpenFile()
	 * 使用指定的选项（如O_RDONLY等）、模式（如0666等）打开文件
	 * @param flag int 选项
	 * @param perm FileMode 模式
	 */
	file, err := os.OpenFile(filename, os.O_APPEND, 0)
	if err != nil {
		fmt.Println("[OpenFile Error] ", err)
	}

	return file
}
```

#### （2）FileWrite

> 文件写入

```go
// 写入文件
n, err := file.Write([]byte("msg"))
n, err := file.WriteAt([]byte("msg"), 0)
n, err := file.WriteString("msg")

func writeFile(file *os.File) {
	/**
	 * 方式 1：
	 * 直接整块写入，覆盖原文件
	 */
	/*msg := []byte("方式 1\n")
	err := os.WriteFile("text.txt", msg, 0)
	if err != nil {
		fmt.Println("[WriteFile Error] ", err)
		return
	}*/

	/**
	 * 方式 2：
	 * 直接写入，返回写入字符数
	 */
	// 向文件中写入 len(b) 字节数据。它返回写入的字节数和可能遇到的任何错误。
	/*n, err := file.Write([]byte("msg1\n"))
	if err != nil {
		fmt.Println("[WriteString Error] ", err)
		return
	} else {
		fmt.Printf("成功写入 %d 个字符\n", n)
	}*/

	/*n, err := file.WriteAt([]byte("msg2\n"), 6)
	if err != nil {
		fmt.Println("[WriteString Error] ", err)
		return
	} else {
		fmt.Printf("成功写入 %d 个字符\n", n)
	}*/

	/*n, err := file.WriteString("msg3\n")
	if err != nil {
		fmt.Println("[WriteString Error] ", err)
		return
	} else {
		fmt.Printf("成功写入 %d 个字符\n", n)
	}*/


	/**
	 * 方式 3：
	 * 带缓冲的方式写入
	 */
	// 创建一个具有默认大小缓冲的 *Writer
	writer := bufio.NewWriter(file)
	// 写入字符串，返回写入字符数，如果 n < len(s) 则返回错误
	n, err := writer.WriteString("哈哈哈哈哈哈\n")
	if err != nil {
		fmt.Println("[WriteString Error] ", err)
		return
	} else {
		fmt.Printf("成功写入 %d 个字节\n", n)
	}
	// 将所有缓冲数据写入
	_ = writer.Flush()

}
```

#### （3）FileRead

> 文件读取

```go
// 读取文件
con := make([]byte, 255)
n, err := file.Read(con)
n, err := file.ReadAt(con, 0)

func readFile(file *os.File) {
	/**
	 * 方式 1：
	 * 直接整块读取（小文件）
	 */
	/*content1, err := os.ReadFile("text.txt")
	if err != nil {
		fmt.Println("[ReadFile ERROR] ", err)
		return
	}
	fmt.Printf("整块读取内容：\n%s\n", content2)
	*/

	/**
	 * 方式 2：不推荐
	 * 从 f 中读取最多 len(b) 字节数据并写入 b
	 * 返回读取的字节数和可能遇到的任何错误
	 * 换行符为： \r\n 占2字节
	 *
	 * n, err := file.ReadAt(content, 5)
	 * 从指定的位置（相对于文件开始位置）读取 len(b) 字节数据并写入 b
	 * 当n<len(b)时，err 总是返回 io.EOF
	 */
	/*content2 := make([]byte, 255)
	n, err := file.Read(content1)
	if err != nil {
		fmt.Println("[Read FILE ERROR] ", err)
		return
	}
	fmt.Printf("读取到 %d 字节：\n%s\n", n, content1)
	*/

	/**
	 * 方式 3：
	 * 带缓冲区的方式读取文件
	 */
	// 创建一个具有默认大小缓冲的 *Reader
	reader := bufio.NewReader(file)
	fmt.Println("== 缓冲区方式读取文件：")
	// 循环读取文件内容
	for {
		// 读取到第一个换行符，读取到 io.EOF 文件结束时返回错误
		content3, err := reader.ReadString('\n')
		if err == io.EOF {
			break
		}
		fmt.Printf(content3)
	}
}
```

#### （4）FileInfo

> 用来描述一个文件对象。

```go
func getFileInfo(file_name string) {
	// 返回一个指定的文件对象的 FileInfo
	file_info, err := os.Stat(file_name)
	if err != nil {
		fmt.Println("获取FileInfo出错：", err)
	} else {
		fmt.Printf("FileInfo: %+v\n", file_info)
		// 基础文件名
		fmt.Println("Name: ", file_info.Name())
		// 文件大小（字节）
		fmt.Println("Size: ", file_info.Size())
		// 文件修改时间
		fmt.Println("ModTime: ", file_info.ModTime().String())
		// 是否是目录
		fmt.Println("IsDir: ", file_info.IsDir())
		// 基础数据源
		fmt.Println("Sys: ", file_info.Sys())

		/**
		 * 返回 FileMode（如 777）
		 * FileMode 代表文件的模式和权限位
		 * FileMode 的方法主要用来进行判断和输出权限
		 */
		file_mode := file_info.Mode()
		fmt.Println("FileMode: ", file_mode)
		// 返回 Unix 权限位
		fmt.Println("FileModeString: ", file_mode.String())
		fmt.Println("FileModePermission: ", file_mode.Perm())
		// 是否是一个目录
		fmt.Println("FileModeIsDir: ", file_mode.IsDir())
		// 是否是一个普通文件
		fmt.Println("FileModeIsDir: ", file_mode.IsRegular())
		// 返回类型位
		fmt.Println("FileModeType: ", file_mode.Type())
	}
}
```

#### （5）FilePermission

> 文件权限处理

```go
func filePermission(file_name string) {
	// 修改前的文件模式
	file, err := os.Stat(file_name)
	if err != nil {
		fmt.Println("获取 FileInfo 出错：", err)
	} else {
		fmt.Println("Chmod Before FileMode: ", file.Mode())
	}
	// 修改文件的 FileMode
	_ = os.Chmod(file_name, 0755)
	// 修改后的文件模式
	file, err = os.Stat(file_name)
	if err != nil {
		fmt.Println("获取 FileInfo 出错：", err)
	} else {
		fmt.Println("Chmod After FileMode: ", file.Mode())
	}

	// 修改文件对象的用户ID和组ID
	//os.Chown(file_name, uid, gid)
	// 修改文件对象的访问时间和修改时间
	//os.Chtimes(file_name, atime, mtime)

	// 使用指定的权限和名称创建一个目录（目录已存在时报错）
	err = os.Mkdir("../os/dir", 0777)
	if err != nil {
		fmt.Println("Mkdir 出错：", err)
	}
	// 使用指定的权限和名称创建一个目录，包括任何必要的上级目录，并返回nil（目录已存在时，不执行任何操作，返回 nil）
	err = os.MkdirAll("../os/dir/11", 0777)
	err = os.MkdirAll("../os/dir/22", 0777)
	if err != nil {
		fmt.Println("MkdirAll 出错：", err)
	}

	// 修改一个文件的名字，移动一个文件
	err = os.Rename("./dir/22", "./dir/33")
	if err != nil {
		fmt.Println("Rename 出错：", err)
	}

	// 删除指定的文件或目录（删除非空目录时报错）
	err = os.Remove("./dir")
	if err != nil {
		fmt.Println("Remove 出错：", err)
	}
	// 删除path指定的文件或目录及它包含的任何下级对象（rm -rf）
	err = os.RemoveAll("./dir")
	if err != nil {
		fmt.Println("RemoveAll 出错：", err)
	}
}
```

#### （6）System

> os 包的其它系统相关函数

```go
func getSystemInfo() {
	// 返回内核提供的主机名
	hostname, err := os.Hostname()
	if err != nil {
		fmt.Println("返回内核提供的主机名出错：", err)
	} else {
		fmt.Println("HostName", hostname)
	}

	// 返回表示环境变量的格式为"key=value"的字符串切片
	fmt.Println("Environ: ", os.Environ())
	// 获取/设置环境变量
	fmt.Println("GoMODULE: ", os.Getenv("GO111MODULE"))
	os.Setenv("GO111MODULE", "auto")
	fmt.Println("GoMODULE: ", os.Getenv("GO111MODULE"))
	// 清空环境变量（谨慎操作）
	//os.Clearenv()
	/**
	 * 让当前程序以给出的状态码code退出。
	 * 一般来说，状态码0表示成功，非0表示出错。
	 * 程序会立刻终止，defer的函数不会被执行。
	 */
	//os.Exit(200)

	// 返回调用者的用户ID（Windows 返回 -1）
	fmt.Println("UID: ", os.Getuid())
	// 返回调用者的有效用户ID（Windows 返回 -1）
	fmt.Println("eUID: ", os.Geteuid())
	// 返回调用者的组ID（Windows 返回 -1）
	fmt.Println("GID: ", os.Getgid())
	// 返回调用者的有效组ID（Windows 返回 -1）
	fmt.Println("eGID: ", os.Getegid())

	// 返回调用者所属的所有用户组的组ID
	groups, _ := os.Getgroups()
	fmt.Println("GID: ", groups)
	// 返回调用者所在进程的进程ID
	fmt.Println("PID: ", os.Getpid())
	// 返回调用者所在进程的父进程的进程ID
	fmt.Println("pPID: ", os.Getppid())
}
```



### 2、io & io/util

#### （1）io

#### （2）io/util

> 包 io/ioutil 实现了一些 I/O 实用程序函数。

```go
package main

import (
	"fmt"
	"io/ioutil"
	"strings"
)

func main() {
	reader := strings.NewReader("这是一段文本")

	// 从r读取数据直到EOF或遇到error，返回读取的数据和遇到的错误。
	cont, err := ioutil.ReadAll(reader)
	if err != nil {
		fmt.Println("ReadAll() Error:", err)
	} else {
		fmt.Println("ReadAll():", string(cont))
	}

	// 从指定的文件中读取数据并返回文件的内容。
	cont, err = ioutil.ReadFile("./test.txt")
	if err != nil {
		fmt.Println("ReadFile() Error:", err)
	} else {
		fmt.Println("ReadFile():", string(cont))
	}

	// 向指定的文件中写入数据。
	// 如果文件不存在将按给出的权限创建文件；
	// 存在则写入数据之前清空文件。
	msg := []byte("新写入的内容")
	err = ioutil.WriteFile("./test.txt", msg, 0755)
	if err != nil {
		fmt.Println("WriteFile() Error:", err)
	}

	// 读取指定的目录的目录信息的有序列表
	file_infos, err := ioutil.ReadDir("../io")
	if err != nil {
		fmt.Println("ReadDir() Error:", err)
	} else {
		fmt.Printf("ReadDir(): %#v\n", file_infos)
		for _, f := range file_infos {
			fmt.Println("ReadDir(): FileName=", f.Name())
		}
	}

	// 在dir目录里创建一个新的、使用prfix作为前缀的临时文件夹，并返回文件夹的名称
	tdir, err := ioutil.TempDir("./", "temp")
	if err != nil {
		fmt.Println("TempDir() Error:", err)
	} else {
		fmt.Printf("TempDir(): %#v\n", tdir)
	}

	// 在dir目录下创建一个新的、使用prefix为前缀的临时文件，以读写模式打开该文件并返回os.File指针
	fos, err := ioutil.TempFile("./", "temp*.php")
	if err != nil {
		fmt.Println("TempFile() Error:", err)
	} else {
		fmt.Printf("TempFile(): %#v\n", fos.Name())
	}
}
```



### 3、用户信息（os/user）

> 允许通过名称或ID查询用户帐户

```go
package main

import (
	"fmt"
	"log"
	"os/user"
)

type User struct {
	Uid      string // 用户ID
	Gid      string // 初级组ID
	Username string
	Name     string
	HomeDir  string
}

type Group struct {
	Gid  string
	Name string
}

func main() {
	// 返回当前的用户帐户
	curUser, err := user.Current()
	if err != nil {
		log.Fatalln("获取当前用户信息出错：", err)
	} else {
		fmt.Printf("当前用户账户：%#v\n", *curUser)
	}
	// 根据用户名查询用户
	curUser, err = user.Lookup(curUser.Username)
	if err != nil {
		log.Fatalln("根据用户名查询用户出错：", err)
	} else {
		fmt.Printf("当前用户账户：%#v\n", *curUser)
	}
	// 根据用户ID查询用户
	curUser, err = user.LookupId(curUser.Uid)
	if err != nil {
		log.Fatalln("根据用户ID查询用户出错：", err)
	} else {
		fmt.Printf("当前用户账户：%#v\n", *curUser)
	}
	// 返回用户所属的组ID列表
	userGroupIds, err := curUser.GroupIds()
	if err != nil {
		log.Fatalln("获取用户所属的组ID列表出错：", err)
	} else {
		fmt.Printf("所属的组ID列表: %#v\n", userGroupIds)
	}

	for k, group_id := range userGroupIds {
		// 根据组ID查找组
		userGroup, err := user.LookupGroupId(group_id)
		if err != nil {
			log.Fatalln("根据组ID查找组出错：", err)
		} else {
			fmt.Printf("所属组 %d: %#v\n", k+1, *userGroup)
		}

		// 根据组名查找组
		_, _ = user.LookupGroup(userGroup.Name)
	}
}
```



### 4、命令行参数解析（flag）

> flag 包实现了命令行参数的解析。 

```go
package main

import (
	"flag"
	"fmt"
)

func main() {
	getArgsByOs()
	typeParse()
	//typeVarParse()
}

func getArgsByOs() {
	// os.Args 保管了命令行参数，第一个是程序名。
	if len(os.Args) != 2 {
		// os.Stdin、os.Stdout、os.Stderr 是指向标准输入、标准输出、标准错误输出的文件描述符。
		// os.Stderr 会自动输出
		fmt.Fprintf(os.Stderr, "Usage: %s host:port \n", os.Args[0])
		// os.Exit 让当前程序以给定状态码code退出。
		// 一般来说，状态码0表示成功，非0表示出错。程序会立刻终止，defer的函数不会被执行。
		os.Exit(-1)
	}

	for _, v := range os.Args {
		fmt.Println(v)
	}
}

func typeParse() {
	/**
	 * 解析 flag 参数为指针
	 * flag.Type(name, value, usage) *Type
	 * 用指定的名称、默认值、使用信息 注册一个 Type 类型 flag
	 * 返回一个保存了该 flag 的值的指针
	 * Type：Bool|Int|Int64|Uint|Uint64|Float64|String|Duration|Var
	 */
	var name = flag.String("name", "", "姓名，默认为空")
	var age = flag.Int("age", 0, "年龄，默认为 0")

	/**
	 * 【重要】
	 * 从 os.Args[1:] 中解析注册的 flag
	 * 必须在所有 flag 都注册好后且访问前执行
	 */
	flag.Parse()

	// 判断 Parse() 是否已经被调用
	flag.Parsed()

	println("========== flag.Type() 方式解析参数 ==========")
	// 返回已被设置（被解析）的 flag 的数量
	nFlag := flag.NFlag()
	fmt.Printf("成功解析参数 %d 个\n", nFlag)
	if nFlag > 0 {
		// 返回已经已注册flag的Flag结构体指针；如果flag不存在的话，返回nil
		fmt.Printf("Flag-name：%+v\n", flag.Lookup("name"))
		fmt.Printf("Flag-age：%+v\n", flag.Lookup("age"))

		fmt.Printf("欢迎 %s , 你 %d 岁了\n", *name, *age)
	}

	// 返回解析flag之后剩余参数的个数
	nArg := flag.NArg()
	fmt.Printf("剩余未解析参数 %d 个\n", nArg)
	if nArg > 0 {
		// 返回解析之后剩下的非flag参数。（不包括命令名）
		//nArgs := flag.Args()

		for i := 0; i < nArg; i++ {
			// 返回解析之后剩下的第i个参数，从0开始索引。
			fmt.Printf("%s \n", flag.Arg(i))
		}
	}
}

func typeVarParse() {
	/**
	 * 解析 flag 参数为变量
	 * flag.TypeVar(&point, name, value, usage)
	 * 用指定的名称、默认值、使用信息注册一个bool类型flag，并将flag的值保存到p指向的变量。
	 * Type：Bool|Int|Int64|Uint|Uint64|Float64|String|Duration
	 */
	var name string
	var age int

	flag.StringVar(&name, "name", "", "姓名，默认为空")
	flag.IntVar(&age, "age", 0, "年龄，默认为 0")
	flag.Parse()

	println("========== flag.TypeVar() 方式解析参数 ==========")
	fmt.Printf("name = %s, age = %d \n", name, age)
}

func customParse() {
	// TODO 自定义解析方式
    flag.Var()
}
```

> \> go run main.go -name YCZ -age 20 



### 5、日期时间（time）

> time包提供了时间的显示和测量用的函数。日历的计算采用的是公历。

- 数据结构

```go
package time

/**
 * Location 代表一个（关联到某个时间点的）地点，以及该地点所在的时区
 */
type Location struct {
    // 内含隐藏或非导出字段
}

// Local代表系统本地，对应本地时区。
var Local *Location = &localLoc

// UTC代表通用协调时间，对应零时区。
var UTC *Location = &utcLoc


/**
 * Time 代表一个纳秒精度的【时间点】
 * 程序中应使用Time类型值来保存和传递时间，而不能用指针（*time.Time）。
 * 时间点可以使用Before、After、Equal方法进行比较。
 * Sub方法让两个时间点相减，生成一个Duration。
 * Add方法给一个时间点加上一个时间段，生成一个新的Time。
 */
type Time struct {
	// 内含隐藏或非导出字段
}


/**
 * Duration 类型代表两个时间点之间经过的时间，以纳秒为单位。【时间段】
 * 可表示的最长时间段大约290年。
 */
type Duration int64

// 时间常量，一般用于指定时间单位，和休眠函数配合使用
const (
    Nanosecond  Duration = 1
    Microsecond          = 1000 * Nanosecond
    Millisecond          = 1000 * Microsecond
    Second               = 1000 * Millisecond
    Minute               = 60 * Second
    Hour                 = 60 * Minute
)

/**
 * Timer 类型代表单次时间事件。
 * 当Timer到期时，当时的时间会被发送给C，除非Timer是被AfterFunc函数创建的。
 */
type Timer struct {
    C <-chan Time
    // 内含隐藏或非导出字段
}

/**
 * Ticker保管一个通道，并每隔一段时间向其传递"tick"
 */
type Ticker struct {
    C <-chan Time // 周期性传递时间信息的通道
    // 内含隐藏或非导出字段
}
```

- 示例

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	/**
	 * Time 类型函数（获取 Time）
	 */
	// 用指定的时间信息，创建 Time
	date_time := time.Date(2022, 1, 1, 0, 0, 0, 0, time.UTC)
	fmt.Println("time.Date()：", date_time)

	// 返回当前本地时间
	now_time := time.Now()
	fmt.Println("time.Now()：", now_time)

	/**
	 * 解析一个格式化的时间字符串，创建 Time
	 * @param layout string 输入格式，必须为 2006-01-02 15:04:05
	 * @param value string 输入值，value中忽略的元素会默认为 0 或 1，时区默认为 UTC
	 *
	 * 解析一个格式化的时间字符串（指定时区）
	 * ParseInLocation(layout, value string, loc *Location)
	 */
	parse_time, err := time.Parse("2006-01-02 15:04:05", "2022-02-12 15:17:30")
	if err != nil {
		fmt.Println("time.Parse() ERROR：", err)
	} else {
		fmt.Println("time.Parse()：", parse_time)
	}

	// 用指定的 Unix 时间戳，创建 Time
	unix_time := time.Unix(1644651630, 123)
	fmt.Println("time.Unix()：", unix_time)

	/* =============================================================================== */

	/**
	 * Time 类型方法
	 */
	curtime := time.Now()

	// 获取t的时区信息
	loc := curtime.Location()
	fmt.Println("Time.Location(): ", loc)
	// 获取t时区的规范名和相对于 UTC 的偏移量（S）
	loc_name, offset := curtime.Zone()
	fmt.Printf("Zone(): name=%s, offset=%d \n", loc_name, offset)

	// 判断t是否代表Time零值的时间点：January 1, year 1, 00:00:00 UTC
	fmt.Println("IsZero(): ", curtime.IsZero())

	// 获取t的本地时区 Time
	loc_time := curtime.Local()
	fmt.Println("Local(): ", loc_time)
	// 获取t的指定时区的 Time
	cus_time := curtime.In(time.UTC)
	fmt.Println("In(): ", cus_time)

	// 获取t的 Unix 时间戳
	fmt.Println("Unix(): ", curtime.Unix())
	// 获取t的 Unix 纳秒级时间戳
	fmt.Println("UnixNano(): ", curtime.UnixNano())
    
    // 时间戳一般用作生成随机数种子
    rand.Seed(time.Now().UnixNano())
    fmt.Println(rand.Intn(10))

	// 判断两个 Time 是否相等
	fmt.Println("Equal(): ", curtime.Equal(time.Now()))
	// 判断 t在u之前：true | t在u之后：true
	is_before := curtime.Before(time.Unix(curtime.Unix()+1, 0))
	fmt.Println("Before(): ", is_before)
	is_after := curtime.After(time.Unix(curtime.Unix()-1, 0))
	fmt.Println("After(): ", is_after)

	// 获取t的 年-月-日 时:分:秒
	year, month, day := curtime.Date()
	year = curtime.Year()
	month = curtime.Month()
	day = curtime.Day()
	fmt.Printf("Date(): year=%d, month=%d, day=%d \n", year, month, day)

	hour, minute, second := curtime.Clock()
	hour = curtime.Hour()
	minute = curtime.Minute()
	second = curtime.Second()
	fmt.Printf("Clock(): hour=%d, minite=%d, second=%d \n", hour, minute, second)

	// 获取 t 对应的ISO 9601标准下的年份和星期编号
	year, week := curtime.ISOWeek()
	fmt.Printf("ISOWeek(): year=%d, week=%d \n", year, week)

	// 获取t对应的该年的第几天
	fmt.Println("YearDay(): ", curtime.YearDay())

	// 获取t对应的该周的周几（0~6）
	fmt.Println("WeekDay(): ", curtime.Weekday())

	// 获取t的纳秒
	fmt.Println("Nanosecond(): ", curtime.Nanosecond())

	// 时间运算
	inc, _ := time.ParseDuration("+24h")
	fmt.Println("Add(): ", curtime.Add(inc))
	fmt.Println("AddDate(): ", curtime.AddDate(0, 0, 2))

	fmt.Println("Sub(): ", curtime.Sub(time.Now()))

	// 返回距离t最近的时间点，该时间点应该满足从Time零值到该时间点的时间段能整除d（d>0）
	// 获取下一个 `整点`
	// 下例将获取 下一个小时的 **:00:00
	dur, _ := time.ParseDuration("+1h")
	fmt.Println("Round(): ", curtime.Round(dur))

	// 类似Round，但是返回的是最接近但早于t的时间点
	// 获取前一个 `整点`
	fmt.Println("Truncate(): ", curtime.Truncate(dur))

	// 格式化 Time
	// layout 必须为 2006-01-02 15:04:05，否则格式化的时间不准确
	fmt.Println("Format(): ", curtime.Format("2006-01-02 15:04:05"))

	// 转为字符串
	fmt.Println("String(): ", curtime.String())

	// location()
	// duration()
	// timer()
}

func location() {
	// 获取指定名称的时区，默认 UTC
	loc, err := time.LoadLocation("")
	if err != nil {
		fmt.Println("LoadLocation() Error: ", err)
	} else {
		fmt.Println("LoadLocation(): ", loc)
	}

	// 使用给定的地点名name和时间偏移量offset（单位秒）创建并返回一个Location
	cus_loc := time.FixedZone("YY", 1001)
	fmt.Println("FixedZone(): ", cus_loc)
}

func duration() {
	/**
	 * 解析一个时间段字符串，生成 Duration
	 * 合法的单位有"ns"、"us"、"µs"、"ms"、"s"、"m"、"h"。
	 * 如"300ms"、"-1.5h"、"2h45m"。
	 */
	pdur, err := time.ParseDuration("-1h")
	if err != nil {
		fmt.Println("ParseDuration() Error: ", err)
	} else {
		fmt.Printf("ParseDuration(): %d \n", pdur)
	}

	// 返回从t到现在经过的时间，生成 Duration
	// 等价于time.Now().Sub(t)
	sdur := time.Since(time.Now())
	fmt.Println("Since(): ", sdur)

	// 将时间段表示为float64类型的 时、分、秒、纳秒
	fmt.Println("Hours(): ", pdur.Hours())
	fmt.Println("Minutes(): ", pdur.Minutes())
	fmt.Println("Seconds(): ", pdur.Seconds())
	fmt.Println("Nanoseconds(): ", pdur.Nanoseconds())

	// 返回时间段采用"72h3m0.5s"格式的字符串表示。
	fmt.Println("Nanoseconds(): ", pdur.String())
}

func timer() {
	/**
	 * Timer
	 * 延时器
	 */
	fmt.Println("Now()", time.Now().Format("2006-01-02 15:04:05"))

	// 延时方式①：定时时间到，向 Timer.C 中写入当前时间
	timer := time.NewTimer(1 * time.Second)
	t := <-timer.C
	fmt.Println("1s 后", t.Format("2006-01-02 15:04:05"))

	// 延时方式②：在 goroutine 中，等待定时时间到，并返回写入当前时间的管道
	// 等价于 NewTimer(d).C
	chanTime := <-time.After(time.Second)
	fmt.Println("2s 后", chanTime.Format("2006-01-02 15:04:05"))

	// 延时方式③：在 goroutine 中，延时、运行
	// AfterFunc 另起一个go程等待时间段d过去，然后调用f。
    // 它返回一个Timer，可以通过调用其Stop方法来取消等待和对f的调用。
	exit := make(chan int)

	fmt.Println("start")
	time.AfterFunc(3*time.Second, func() {
		fmt.Println("3s 后", time.Now().Format("2006-01-02 15:04:05"))
		exit <- 1
	})

	// 等待 goroutine 执行完毕
	<-exit
    
    
	/**
	 * Ticker
	 * 定时器
	 */
	// 定时方式①：NewTicker()
	ticker := time.NewTicker(time.Second)
	cnt := 0
	for t := range ticker.C {
		fmt.Println("Ticker()", t.Format("2006-01-02 15:04:05"))
		cnt++
		if cnt > 9 {
			break
		}
	}

	// 定时方式②：Tick()
	// Tick 是NewTicker的封装，只提供对Ticker的通道的访问。如果不需要关闭Ticker，本函数就很方便。
	chanT := time.Tick(2 * time.Second)
	cnt = 0
	for t := range chanT {
		fmt.Println("Tick()", t.Format("2006-01-02 15:04:05"))
		cnt++
		if cnt > 9 {
			break
		}
	}
}
```



### 6、字符串函数（strings）

```go
package main

import (
	"fmt"
	"io"
	"strings"
	"sync"
	"unicode"
)

func main() {
	StringsOperation()
	ReaderOperation()
	ReplacerOperation()
}

func StringsOperation() {
	/**
	 * 判断字符串中是否存在子串
	 */
	// 判断两个utf-8编码字符串（将unicode大写、小写、标题三种格式字符视为相同）是否相同。
	fmt.Println("字符串比较：", strings.EqualFold("大A", "大a"))
	// 判断s是否有前缀字符串prefix
	fmt.Println("字符串前缀判断：", strings.HasPrefix("No.20220215", "No."))
	// 判断s是否有后缀字符串suffix
	fmt.Println("字符串后缀判断：", strings.HasSuffix("No.20220215", "No."))
	// 判断字符串s是否包含子串substr
	fmt.Println("字符串中是否包含子串：", strings.Contains("我爱中国", "中国"))
	// 判断字符串s是否包含utf-8码值r
	fmt.Println("字符串中是否包含utf-8码值：", strings.ContainsRune("abcd", 97))
	// 判断字符串s是否包含字符串chars中的任一字符
	fmt.Println("字符串中是否包含任意字符：", strings.ContainsAny("abcd", "ac"))

	// 返回字符串s中有几个不重复的sep子串。
	fmt.Println("字符串中是否包含几个子串：", strings.Count("aaaaccc", "ac"))

	/**
	 * 字符串比较
	 * =0：相等
	 * <0：a<b
	 * >0：a>b
	 */
	fmt.Println("字符串比较：", strings.Compare("ab", "c"))

	/**
	 * 字符串查找
	 */
	// 子串在字符串中 【第一次|最后一次】 出现的位置，不存在则返回-1。
	fmt.Println("子串位置：", strings.Index("ABCDEFG", "EF"))
	fmt.Println("子串位置：", strings.LastIndex("ABCDEFG", "EF"))
	// 字符在字符串中 【第一次|最后一次】 出现的位置，不存在则返回-1。
	fmt.Println("子串位置：", strings.IndexByte("ABCDEFG", 'F'))
	fmt.Println("子串位置：", strings.LastIndexByte("ABCDEFG", 'F'))
	// unicode码值在字符串中第一次出现的位置，不存在则返回-1。
	fmt.Println("子串位置：", strings.IndexRune("ABCDEFG", 66))
	// 字符串chars中的任一utf-8码值在s中 【第一次|最后一次】 出现的位置，如果不存在或者chars为空字符串则返回-1。
	fmt.Println("子串位置：", strings.IndexAny("ABCDEFG", "FD"))
	fmt.Println("子串位置：", strings.LastIndexAny("ABCDEFG", "FD"))
	// 字符串中 【第一个|最后一个】 满足函数f的位置i，不存在则返回-1。
	// 该函数判断 utf-8 码值满足 f(r)==true 的字符
	f := func(c rune) bool {
		return unicode.Is(unicode.Han, c)
	}
	fmt.Println(strings.IndexFunc("Hello, 世界", f))
	fmt.Println(strings.LastIndexFunc("Hello, 世界", f))

	/**
	 * 字符串大小写转换
	 */
	// 单词首字母转换为大写
	fmt.Println("首字母大写：", strings.Title("hello world"))
	// 字符串转小写
	fmt.Println("字符串转小写：", strings.ToLower("HELLO WORLD"))
	// 字符串转大写
	fmt.Println("字符串转大写：", strings.ToUpper("hello world"))
	// 将所有字母都转为对应的标题版本
	fmt.Println("字符串转标题版本：", strings.ToTitle("hello world"))

	/**
	 * 字符串重复
	 */
	fmt.Println("字符串重复：", strings.Repeat("abc ", 5))

	/**
	 * 字符串替换
	 */
	// 将s中前n个不重叠old子串都替换为new的新字符串，如果n<0会替换所有old子串
	fmt.Println("字符串替换：", strings.Replace("我爱 PHP", "PHP", "GO", 1))

	// 将s的每一个unicode码值r都替换为 mapping(r)，返回这些新码值组成的字符串拷贝。
	// 如果mapping返回一个负值，将会丢弃该码值而不会被替换。（返回值中对应位置将没有码值）
	rot13 := func(r rune) rune {
		switch {
		case r >= 'A' && r <= 'Z':
			return 'A' + (r-'A'+13)%26
		case r >= 'a' && r <= 'z':
			return 'a' + (r-'a'+13)%26
		}
		return r
	}
	fmt.Println(strings.Map(rot13, "'Twas brillig and the slithy gopher..."))

	/**
	 * 字符串裁剪
	 */
	// 裁剪字符串【两端|左边|右边】的指定字符
	fmt.Println("字符串裁剪：", strings.Trim("~~我爱 ~ PHP~", "~"))
	fmt.Println("字符串裁剪：", strings.TrimLeft("~~我爱 ~ PHP~", "~"))
	fmt.Println("字符串裁剪：", strings.TrimRight("~~我爱 ~ PHP~", "~"))
	// 裁剪字符串两端的空白字符
	fmt.Println("字符串裁剪：", strings.TrimSpace("    我爱 GO  "))
	// 裁剪字符串【前缀|后缀】
	fmt.Println("字符串裁剪：", strings.TrimPrefix("^我爱 GO  $", "^"))
	fmt.Println("字符串裁剪：", strings.TrimSuffix("^我爱 GO  $", "$"))
	// 自定义函数裁剪字符串
	//strings.TrimFunc()
	//strings.TrimLeftFunc()
	//strings.TrimRightFunc()

	/**
	 * 字符串的切割 与 连接
	 * 字符串 与 切片的转换
	 */
	// 用空格将字符串切割成切片
	fmt.Println("字符串切割:", strings.Fields("A B C D EF IJ"))
	// 自定义函数切割字符串
	//strings.FieldsFunc()

	// 用指定字符将字符串切割成切片
	fmt.Println("字符串切割:", strings.Split("A,B,C,D,E,F,I,J", ","))
	// 用指定字符将字符串切割成切片，并指定切隔的成员数量
	// n < 0：切割到末尾
	// n = 0：nil
	// n > 0：指定数量
	fmt.Println("字符串切割:", strings.SplitN("A,B,C,D,E,F,I,J", ",", 3))
	// 用从字符串中出现的sep后面切断的方式进行分割
	fmt.Println("字符串切割:", strings.SplitAfter("A,B,C,D,E,F,I,J", ","))
	fmt.Println("字符串切割:", strings.SplitAfterN("A,B,C,D,E,F,I,J", ",", 5))

	// 将切片连接为一个字符串，用sep来连接
	fmt.Println("字符串连接：", strings.Join([]string{"Ab", "Ef", "Ij"}, ","))
}

/**
 * Reader 类型通过从一个字符串读取数据，
 * 实现了io.Reader、io.Seeker、io.ReaderAt、io.WriterTo、io.ByteScanner、io.RuneScanner接口。
 */
type Reader struct {
	s        string
	i        int64 // current reading index
	prevRune int   // index of previous rune; or < 0
}

func ReaderOperation() {
	// 创建一个从字符串读取数据的 *Reader
	reader := strings.NewReader("从字符串中读取的 reader")
	// 返回 reader 中还没有被读取的字符串长度
	fmt.Println("Len()", reader.Len())
	// ...
}

type Replacer struct {
	once   sync.Once // guards buildOnce method
	r      replacer
	oldnew []string
}

type replacer interface {
	Replace(s string) string
	WriteString(w io.Writer, s string) (n int, err error)
}

func ReplacerOperation() {
	// 使用提供的多组old、new字符串对创建并返回一个*Replacer。替换是依次进行的，匹配时不会重叠。
	rep := strings.NewReplacer("<", "&lt;", ">", "&gt;")
	// 返回s的所有替换进行完后的拷贝
	fmt.Println(rep.Replace("This is <b>HTML</b>!"))
	// ...
}
```

### 7、正则表达式搜索（regexp）

### 7、路径函数（path & path/filepath）

#### （1）path

> 与 path/filepath 包的函数类似。

```go
package main

import (
	"fmt"
	"path"
)

func main() {
	// 判断路径是否是一个绝对路径
	fmt.Println("IsAbs()", path.IsAbs("F:\\go_demo\\path"))
	// 分隔路径中的目录和文件
	dir, file := path.Split("./main.go")
	fmt.Printf("Split() dir = %s, file = %s \n", dir, file)
	// 连接路径，空字符串元素会被忽略
	fmt.Println("Join()", path.Join("/www", "data", "go"))
	// 返回最后一个元素所在目录
	fmt.Println("Dir()", path.Dir("/www/data/go/main.go"))
	// 返回最后一个元素
	fmt.Println("Base()", path.Base("/www/data/go/main.go"))
	// 返回path文件扩展名（如：.go）
	fmt.Println("Ext()", path.Ext("/www/data/go/main.go"))
	// 返回等价的最短路径：realpath()
	fmt.Println("Clean()", path.Clean("/www/data/go/../go"))
}
```



#### （2）filepath

> filepath包实现了兼容各操作系统的文件路径的实用操作函数。

```go
package main

import (
	"fmt"
	"io/fs"
	"path/filepath"
)

func main() {
	// 判断路径是否是一个绝对路径
	fmt.Println("IsAbs()", filepath.IsAbs("F:/"))
	// 返回 path 代表的绝对路径
	// 如果path不是绝对路径，会加入当前工作目录以使之成为绝对路径
	abs, _ := filepath.Abs("./")
	fmt.Println("Abs()", abs)
	// 返回以 basepath 为基准的相对路径
	rel, _ := filepath.Rel("/a/b", "/a/b/c")
	fmt.Println("Rel()", rel)
	// 将路径使用路径列表分隔符分开，见 os.PathListSeparator
	fmt.Println("SplitList() ", filepath.SplitList("/a/b/c;/usr/bin"))
	// 分隔路径中的目录和文件
	dir, file := filepath.Split("./main.go")
	fmt.Printf("Split() dir = %s, file = %s \n", dir, file)
	// 连接路径，空字符串元素会被忽略
	fmt.Println("Join()", filepath.Join("/www", "data", "go"))
	// 将path中的斜杠（'/'）替换为路径分隔符
	fmt.Println("FromSlash()", filepath.FromSlash("/www/data/go/main.go"))
	// 将path中的路径分隔符替换为斜杠（'/'）
	fmt.Println("ToSlash()", filepath.ToSlash("\\www\\data\\go\\main.go"))
	// 返回分区名
	fmt.Println("VolumeName()", filepath.VolumeName("F:\\go_demo\\path"))
	// 返回最后一个元素所在目录
	fmt.Println("Dir()", filepath.Dir("/www/data/go/main.go"))
	// 返回最后一个元素
	fmt.Println("Base()", filepath.Base("/www/data/go/main.go"))
	// 返回path文件扩展名（如：.go）
	fmt.Println("Ext()", filepath.Ext("/www/data/go/main.go"))
	// 返回等价的最短路径：realpath()
	fmt.Println("Clean()", filepath.Clean("/www/data/go/../go"))
	// 返回path指向的符号链接（软链接）所包含的路径。返回链接文件的实际路径
	link, _ := filepath.EvalSymlinks("main.go")
	fmt.Println("EvalSymlinks()", link)
	// match() 匹配文件

	// 返回所有匹配的文件
	matches, _ := filepath.Glob("./*.go")
	fmt.Println("Glob()", matches)
	// 遍历指定目录下的所有文件
	_ = filepath.Walk("./", func(path string, info fs.FileInfo, err error) error {
		fmt.Println(path)
		return nil
	})
}
```



### 8、反射（reflect）

> 任意值在反射中都可以理解为由 `reflect.Type` 和 `reflect.Value` 两部分组成。

```go
/**
 * Type 类型用来表示一个 Go 类型。
 */
type Type interface {
    // 内含隐藏或非导出字段
}

// 动态获取输入参数接口中的值类型
reflect.TypeOf()
// 获取值数量
reflect.Typeof().NumField()
// 用来判断类型
reflect.TypeOf().Kind()

/**
 * Value 为 Go 值提供了反射接口。
 */
type Value struct {
    // 内含隐藏或非导出字段
}

// 获取输入参数接口中的数据值
reflect.ValueOf()
// 用来获取值
reflect.ValueOf().Fidle(int)
```



### 9、上下文（context）



### 10、同步（sync）



### 11、编码与解码

#### （2）Base64（encoding/base64）

```go
package main

import (
	"encoding/base64"
	"fmt"
)

func main() {
	original := []byte("key=value&flag=1")
	// base64 编码、解码
	fmt.Printf("original_string: %s\n", original)
	encode := base64.StdEncoding.EncodeToString(original)
	fmt.Println("base64_encoding: ", encode)
	decode, _ := base64.StdEncoding.DecodeString(encode)
	fmt.Printf("base64_decoding: %s\n", decode)
	// URL 中使用时的 编码、解码
	urlEncode := base64.URLEncoding.EncodeToString(original)
	fmt.Println("base64_url_encoding: ", urlEncode)
	urlDecode, _ := base64.URLEncoding.DecodeString(urlEncode)
	fmt.Printf("base64_url_decoding: %s\n", urlDecode)
}
```



### 14、日志（log）

```go
package main

import (
	"log"
	"os"
)

// 定制 Logger
var (
	Info    *log.Logger
	Warning *log.Logger
	Error   *log.Logger
)

func init() {
	// 设置标准logger的输出前缀
	log.SetPrefix("[Logger] ")
	// 设置标准logger的输出选项
	log.SetFlags(log.Ldate | log.Lmicroseconds | log.Llongfile)

	// 以追加方式打开文件，准备写入日志（文件不存在时，新建）
	log_file, err := os.OpenFile("test.log", os.O_APPEND|os.O_CREATE, 0777)
	if err != nil {
		log.Fatalln("日志文件打开失败", err)
	}

	// 设置标准logger的输出目的地，默认是标准错误输出（打印到控制台）
	log.SetOutput(log_file)

	/**
	 * 定制 Logger
	 * 参数：输出目的地，前缀，日志格式
	 */
	Info = log.New(log_file, "[Info] ", log.Ldate|log.Ltime|log.Lshortfile)
	Warning = log.New(log_file, "[Warning] ", log.Ldate|log.Ltime|log.Llongfile)
	Error = log.New(log_file, "[Error] ", log.Ldate|log.Lmicroseconds|log.Llongfile)
}

func main() {
	// 将生成的格式化字符串输出到标准logger
	log.Println("Print Printf Println")
	// 输出到标准logger后，调用 os.Exit(1)
	log.Fatalln("Fatal Fatalf Fatalln")
	// 输出到标准logger后，调用 panic
	log.Panicln("Panic Panicf Panicln")

	// 使用定制的 logger
	Info.Println("自定义的 Info")
	Warning.Println("自定义的 Warning")
	Error.Println("自定义的 Error")
}
```

### 15、数据类型转换（strconv）

> strconv包实现了基本数据类型和其字符串表示的相互转换。

```go
package main

import (
	"fmt"
	"strconv"
	"unsafe"
)

func main() {
	/**
	 * （1）string 与 int 之间的转换
	 */
	// Itoa()
	num := 12306
	str := strconv.Itoa(num)
	fmt.Printf("原类型：%T\t 值：%d\t 占用字节：%d \n", num, num, unsafe.Sizeof(num))
	fmt.Printf("Itoa 后类型：%T\t 值：%s 占用字节：%d \n", str, str, unsafe.Sizeof(str))

	// Atoi()
	str1 := "2022"
	str2 := "2002年的第一场雪"
	i1, err := strconv.Atoi(str1)
	if err != nil {
		fmt.Println("str1 Atoi 转换出错：", err)
	} else {
		fmt.Printf("str1 Atoi 结果：%d \n", i1)
	}
	i2, err := strconv.Atoi(str2)
	if err != nil {
		fmt.Println("str2 Atoi 转换出错：", err)
	} else {
		fmt.Printf("str2 Atoi 结果：%d \n", i2)
	}

	// 其它类型转换成 string
	str3 := fmt.Sprintf("这里自定义 string 格式：%d-%d-%d", 2022, 01, 01)
	fmt.Println(str3)

	/**
	 * （2）Parse 系列函数
	 * 将 string 转换为其它类型
	 */
	/**
	 * ParseBool() 将 str 转换成 bool
	 * It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False.
	 */
	boo, err := strconv.ParseBool("1")
	if err != nil {
		fmt.Println(err)
	} else {
		println("ParseBool: ", boo)
	}

	/**
	 * ParseInt() 返回字符串表示的整数值（接受正负号）
	 * ParseUint() 返回字符串表示的整数值（不接受正负号），无符号整型
	 * base：说明给定字符串的进制，取值范围是 2 到 36。如果 base 为 0，则会从字符串前置判断，“0x”是 16 进制，“0”是 8 进制，否则是 10 进制。
	 * bitSize：指定返回值类型。0,8,16,32,64，分别代表 int、int8、int16、int32、int64。
	 */
	str2int, err := strconv.ParseInt("011", 2, 0)
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println("ParseInt: ", str2int)
	}

	/**
	 * ParseFloat() 解析一个表示浮点数的字符串并返回其值
	 * bitSize 指定了返回值的类型，32 表示 float32 ，64 表示 float64。
	 */
	str2flo, err := strconv.ParseFloat("123.456", 64)
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println("ParseFloat: ", str2flo)
	}

	/**
	 * （3）Format 系列函数
	 * 其它类型转 string
	 */
	// 根据 bool 的值返回 "true" 或 "false"。
	fmt.Println("FormatBool: ", strconv.FormatBool(true))
	// 返回 i 的 base 进制的字符串表示。
	// base 必须在 2~36 之间，结果中会使用小写字母'a'到'z'表示大于10的数字
	fmt.Println("FormatInt: ", strconv.FormatInt(-10, 2))
	fmt.Println("FormatUint: ", strconv.FormatUint(10, 2))
	/**
	 * 将浮点数表示为字符串并返回
	 * fmt：格式：
		'f'（-ddd.dddd）
		'b'（-ddddp±ddd，指数为二进制）
		'e'（-d.dddde±dd，十进制指数）
		'E'（-d.ddddE±dd，十进制指数）
		'g'（指数很大时用'e'格式，否则'f'格式）
		'G'（指数很大时用'E'格式，否则'f'格式）
	 * prec：精度，当fmt为 f、e、E 时，表示小数位数；当 fmt 为 g、G 时，它控制总数字个数。
	 * bitSize：参数f的来源类型
	*/
	fmt.Println("FormatFloat: ", strconv.FormatFloat(123.456, 'f', 5, 64))

	/**
	 * （4）Append 系列函数
	 * 将指定类型转换成字符串后追加到一个切片中
	 */
	/**
	 * AppendBool(dst, b) 等价于 append(dst, FormatBool(b)...)
	 * AppendInt(dst, i, base) 等价于 append(dst, FormatInt(I, base)...)
	 * AppendUint(dst, i, base) 等价于 append(dst, FormatUint(I, base)...)
	 * AppendFloat(dst, f, fmt, prec, bitSize) 等价于append(dst, FormatFloat(f, fmt, prec, bitSize)...)
	 */
	byt_sli := []byte("将一个Bool追加到切片中：")
	byt_sli = strconv.AppendBool(byt_sli, true)
	fmt.Printf(string(byt_sli))

	// 相同大类型之间的相互转换
	// type()
}
```

### 

### 17、双向链表（container/list）

> list包实现了双向链表。 

```go
package main

import (
	"container/list"
	"fmt"
)

// 链表
type List struct {
	// 链表的哨兵元素，
	root Element
	// 链表长度
	len int
}

// 链表元素
type Element struct {
	// 下一个、上一个元素指针
	next, prev *Element
	// 链表指针
	list *List
	// 元素值
	Value interface{}
}

/**
 * 利用链表元素的 Next() 实现链表遍历
 * func (e *Element) Next() *Element
 * func (e *Element) Prev() *Element
 */

// 遍历链表
func foreachList(list *list.List) {
	for e := list.Front(); e != nil; e = e.Next() {
		fmt.Println(e.Value)
	}
}

func main() {
	// New 创建一个链表
	li := list.New()
	// Init 清空链表
	li = li.Init()
	// Len 返回链表中元素的个数，O(1)
	fmt.Println("Len()", li.Len())
	// 返回链表的第一个元素或nil
	fmt.Println("Front()", li.Front())
	// 返回链表的最后个元素或nil
	fmt.Println("Back()", li.Back())
	// 向链表的【第一个|最后一个】位置插入一个元素，返回生成的新元素
	e1 := li.PushFront(11)
	e9 := li.PushBack(99)

	subLi := list.New()
	_ = subLi.PushBack("sub1")
	subLi.PushBack("sub2")
	subLi.PushBack("sub3")

	// 向链表的【第一个|最后一个】位置插入一个列表
	// 创建链表other的拷贝，并将拷贝的最后一个位置连接到链表l的第一个位置
	li.PushFrontList(subLi)
	// 创建链表other的拷贝，并将拷贝的第一个位置连接到链表l的最后一个位置
	li.PushBackList(subLi)

	// 向链表中指定元素的【前面|后面】插入元素，返回插入的元素
	e8 := li.InsertBefore(88, e9)
	e2 := li.InsertAfter(22, e1)

	// 将链表中的指定元素移至【第一个|最后一个位置】
	li.MoveToFront(e1)
	li.MoveToBack(e9)

	// 将链表中的指定元素e移至mark的【前面|后面】
	li.MoveAfter(e2, e1)
	li.MoveBefore(e8, e9)

	// 删除链表中的指定元素，并返回元素值
	fmt.Println("Remove()", li.Remove(e1))

	foreachList(li)
}
```

### 18、上下文（context）

>  `Context` 是一个接口，它具备手动、定时、超时发出取消信号、传值等功能，主要用于控制多个 `goroutine` 之间的协作，尤其是取消操作。并且是并发安全的。

- Context 接口方法

```go
type Context interface {
    /**
     * 置的截止时间，时间到 Context 会自动发起取消请求
     * deadline 是截止时间
     * ok 代表是否设置了截止时间
     */
    Deadline() (deadline time.Time, ok bool)
    /**
     * 若能从 Done() 返回的只读chan中获取数据，则说明 Context 已经发起了取消信号。
     */
    Done() <-chan struct{}
    /**
     * Err() 返回 Context 取消的原因
     */
    Err() error
    /**
     * 获取该 Context 上绑定的值，是一个键值对，要通过 key 才能获取对应的值。
     */
    Value(key interface{}) interface{}
}
```

- Context 树

```go
// 获取一个根节点 Context
func Background() Context

// 生成一个可取消的 Context
func WithCancel(parent Context) (ctx Context, cancel CancelFunc)

// 生成一个可定时取消的 Context，参数 d 为定时取消的具体时间
func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)

// 生成一个可超时取消的 Context，参数 timeout 用于设置多久后取消
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)

// 生成一个可携带 key-value 键值对的 Context
func WithValue(parent Context, key, val interface{}) Context
```

- Context 使用原则
  - Context 不要放在结构体中，要以参数的方式传递。
  - Context 作为函数参数时，要放在第一位。
  - 传递 Context 时，不要传 nil。

### 10、随机数

```go
// 为 rand 设置一个种子
rand.Seed(time.Now().UnixNano())

// 生成从 [0,100) 的随机数
ran := rand.Intn(100)

fmt.Println(ran)
```



## 四、第三方库

### 1、日志：uber-go/zap

> 官网： https://github.com/uber-go/zap 
>
>  `zap` 是 `uber` 开源的 `Go` 高性能日志库，支持不同的日志级别， 能够打印基本信息等，但不支持日志的分割，这里我们可以使用 `lumberjack` 也是 `zap` 官方推荐用于日志分割，结合这两个库我们就可以实现以下功能的日志机制： 
>
> - 能够将事件记录到文件中，而不是应用程序控制台；
> - 日志切割能够根据文件大小、时间或间隔等来切割日志文件；
> - 支持不同的日志级别，例如 `DEBUG` ， `INFO` ， `WARN` ， `ERROR` 等；
> - 能够打印基本信息，如调用文件、函数名和行号，日志时间等；



### 2、MySQL 操作

#### （1）MySQL 驱动

```
// 下载 mysql 驱动库
go get github.com/go-sql-driver/mysql 
```

#### （2）标准库 database/sql 使用

```go
package main

import (
    _ "github.com/go-sql-driver/mysql"
	"database/sql"
	"fmt"
	"log"
)

func checkErr(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

func main() {
	// 打开一个 dirverName 指定的数据库，dataSourceName 指定数据源
	// Open("数据库类型", "用户名:密码@tcp(地址:端口)/数据库名")
	db, err := sql.Open("mysql", "root:root@/test")
	checkErr(err)
    
    defer db.Close()

	/**
	 * 执行一次命令（包括查询、删除、更新、插入等），不返回任何执行结果。
	 * Result 是对已执行的SQL命令的总结。
	 * Result.LastInsertId    # 获取INSERT操作的自增ID
	 * Result.RowsAffected    # 获取INSERT、UPDATE、DELETE操作影响的行数
	 */
	//res, err := db.Exec("insert into user(username, created_at) values(?, ?);", "YCZ2", time.Now().Unix())
	res, err := db.Exec("update user set username = ? where id = ?;", "YCZ3", 3)
	//res, err := db.Exec("delete from user where id = ?;", 1)

	checkErr(err)
	rAffected, err := res.RowsAffected()
	fmt.Println("Exec 影响行数：", rAffected)

	/**
	 * 执行一次查询，返回多行结果（即Rows），一般用于执行select命令。
	 */
	rows, err := db.Query("select * from user;")
	checkErr(err)
	// Next 准备用于 Scan 方法的下一行结果。
	// 如果成功会返回真，如果没有下一行或者出现错误会返回假。
	fmt.Printf("========== 查询结果 ========== \n")
	fmt.Printf("ID \t Username \t CreatedAt \n")
	var (
		id       int
		username string
		time     int
	)
	for rows.Next() {
		// Scan 将当前行各列结果填充进dest指定的各个值中
		err = rows.Scan(&id, &username, &time)
		checkErr(err)

		fmt.Printf("%d \t %s \t\t %d \n", id, username, time)
	}

	/**
	 * 执行一次查询，并期望返回最多一行结果（即Row）。
	 * QueryRow总是返回非nil的值，直到返回值的Scan方法被调用时，才会返回被延迟的错误。（如：未找到结果）
	 */
	row := db.QueryRow("select * from user;")
	err = row.Scan(&id, &username, &time)
	checkErr(err)
	fmt.Printf("===== QueryRow 获取一行结果：\n%d \t %s \t\t %d \n", id, username, time)

	// 预处理
	/*stmt, err := db.Prepare("select * from user where id = ?;")
	res, err = stmt.Exec(3)
	rows, err = stmt.Query(3)
	row = stmt.QueryRow(3)
	err = stmt.Close()*/

	// 事务
	/*tx, err := db.Begin()
	res, err = tx.Exec("update user set username = ?, where id = ?", "", 2)
	rows, err = tx.Query("", "")
	row = tx.QueryRow("", "")
	err = tx.Commit()
	err = tx.Rollback()*/
}
```



#### （3）三方库 sqlx 的基本使用

> 下载：`go get github.com/jmoiron/sqlx`

```go
package main

import (
	"fmt"
	_ "github.com/go-sql-driver/mysql"
	"github.com/jmoiron/sqlx"
)

type Person struct {
	Id   int    `db:"id"`
	Name string `db:"name"`
	Age  int    `db:"age"`
}

func main() {
	// 打开数据库
	// Open("数据库类型", "用户名:密码@tcp(地址:端口)/数据库名")
	db, err := sqlx.Open("mysql", "root:root@tcp(127.0.0.1:3306)/test")
	if err != nil {
		fmt.Println("数据库连接出错：", err)
		return
	}

	defer db.Close()

	// Insert Update Delete
	/*res, err := db.Exec("insert into name(`name`, `age`) values(?, ?)", "YCZ", 20)
	if err != nil {
		fmt.Println("插入出错：", err)
		return
	} else {
		// 获取自增ID
		id, err := res.LastInsertId()
		if err != nil {
			fmt.Println("获取自增ID出错：", err)
		} else {
			fmt.Println("自增 ID = ", id)
		}
	}*/

	// Update
	/*res, err := db.Exec("update name set name = 'YYY' where id > ?", 2)
	if err != nil {
		fmt.Println("插入出错：", err)
		return
	} else {
		// 获取受影响的行
		rows, err := res.RowsAffected()
		if err != nil {
			fmt.Println("获取受影响的行出错：", err)
		} else {
			fmt.Println("更新条数：", rows)
		}
	}*/

	// Delete
	/*res, err := db.Exec("delete from name where id = ?", 6)
	if err != nil {
		fmt.Println("插入出错：", err)
		return
	} else {
		// 获取受影响的行
		rows, err := res.RowsAffected()
		if err != nil {
			fmt.Println("获取受影响的行出错：", err)
		} else {
			fmt.Println("删除条数：", rows)
		}
	}*/

	// 查询操作
	var per []Person
	err = db.Select(&per, "select * from `name`")
	if err != nil {
		fmt.Println("查询出错：", err)
	} else {
		fmt.Println("结果：", per)
	}
    
    // 事务
    db.Begin()		// 开始事务
	db.Commit()		// 提交事务
	db.Rollback()	// 回滚事务
}
```



### 3、Redis 操作

#### （1）安装 redis 库

```
# Redis 库-1
go get github.com/garyburd/redigo/redis
# Redis 库-2
go get github.com/go-redis/redis
```

> 生成文件路径：
>
> $GOPATH\src\github.com\garyburd\redigo （GOPATH 模式）
>
> $GOPATH\pkg\mod\github.com\garyburd\redigo （GoModules 模式）

#### （2）基本使用

```go
package main

import (
	"fmt"
	"github.com/garyburd/redigo/redis"
)

func main(){
	// 连接 Redis 服务
	c, err := redis.Dial("tcp", "127.0.0.1:6379")
	if err != nil {
		fmt.Println("连接出错：", err)
		return
	}

	// 关闭连接
	defer c.Close()

	// 执行命令
	c.Do("auth", "ycz")

	// 将结果转换成 string
	res, err := redis.String(c.Do("get", "name"))
	if err != nil {
		fmt.Println("执行出错：", err)
		return
	}

	fmt.Println("结果：", res)
}
```

#### （3）redis连接池

> 减少往返时间

```go
package main

import (
	"fmt"
	"github.com/garyburd/redigo/redis"
)

var pool *redis.Pool

// 初始化连接池
func init() {
	pool = &redis.Pool{
		// 最大空闲连接数
		MaxIdle: 16,
		// 最大连接数，0 表示没有限制
		MaxActive: 1024,
		// 最大空闲连接等待时间
		IdleTimeout: 300,
		// 初始化连接代码
		Dial: func() (redis.Conn, error) {
			return redis.Dial("tcp", "127.0.0.1:6379")
		},
	}
}

func main() {
	// 从连接池中获取一个连接
	c := pool.Get()

	// 关闭连接
	defer c.Close()

	// 执行命令
	c.Do("auth", "ycz")
	c.Do("set", "name", "YCZ")

	// 将结果转换成 string
	res, err := redis.String(c.Do("get", "name"))
	if err != nil {
		fmt.Println("执行出错：", err)
		return
	}

	fmt.Println("结果：", res)
}

```

> 注：用 `pool.Close()` 关闭后，就不能从连接池中取连接了。

### 4、配置：viper

> 官网：https://github.com/spf13/viper

```
# 安装
go get github.com/spf13/viper
```

### 5、GORM

> 安装：`go get -u github.com/jinzhu/gorm`

### （1）定义模型

```go
/**
 * 模型定义
 * gorm.Model 包含基本字段：ID、CreatedAt、UpdatedAt、DeletedAt。
 * 对应数据表字段为：id、created_at、updated_at、deleted_at。
 * 注意：
 * 1.复数表名：数据表名称是结构体名称的复数形式（users）。
 * 2.蛇形列名：列名是字段名的蛇形小写形式，用 `gorm:"column:user_name"` 指定列名。
 */
type User struct {
	gorm.Model        // 继承 gorm.Model 的字段
	ID         int    `gorm:"type:int(10);primary_key;auto_increment"`
	Username   string `gorm:"type:varchar(20);default:'';comment:用户名"`
	CreatedAt  int64  `gorm:"type:int(10);default:0;comment:创建时间"`
	ignore     string `gorm:"-"` // 忽略这个字段
}

// 设置 `User` 的表名，默认为：users
func (User) TableName() string {
	return "user"
}
```

### （2）模型标签

> 【表结构】标签

| 标签            | 说明                                     |
| --------------- | ---------------------------------------- |
| Column          | 指定列的名称                             |
| Type            | 指定列的类型                             |
| Size            | 指定列的大小，默认是 255                 |
| PRIMARY_KEY     | 指定一个列作为主键                       |
| UNIQUE          | 指定一个唯一的列                         |
| DEFAULT         | 指定一个列的默认值                       |
| PRECISION       | 指定列的数据的精度                       |
| NOT NULL        | 指定列的数据不为空                       |
| AUTO_INCREMENT  | 指定一个列的数据是否自增                 |
| INDEX           | 创建带或不带名称的索引，同名创建复合索引 |
| UNIQUE_INDEX    | 类似 `索引`，创建一个唯一的索引          |
| EMBEDDED        | 将 struct 设置为 embedded                |
| EMBEDDED_PREFIX | 设置嵌入式结构的前缀名称                 |
| -               | 忽略这些字段                             |

> 「关联」的结构标签

| 标签                             | 说明                   |
| -------------------------------- | ---------------------- |
| MANY2MANY                        | 指定连接表名称         |
| FOREIGNKEY                       | 指定外键               |
| ASSOCIATION_FOREIGNKEY           | 指定关联外键           |
| POLYMORPHIC                      | 指定多态类型           |
| POLYMORPHIC_VALUE                | 指定多态的值           |
| JOINTABLE_FOREIGNKEY             | 指定连接表的外键       |
| ASSOCIATION_JOINTABLE_FOREIGNKEY | 指定连接表的关联外键   |
| SAVE_ASSOCIATIONS                | 是否自动保存关联       |
| ASSOCIATION_AUTOUPDATE           | 是否自动更新关联       |
| ASSOCIATION_AUTOCREATE           | 是否自动创建关联       |
| ASSOCIATION_SAVE_REFERENCE       | 是否引用自动保存的关联 |
| PRELOAD                          | 是否自动预加载关联     |

### （3）模型的 CURD

```go
package main

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
	"log"
	"time"
)

func checkErr(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

/**
 * 模型定义
 * gorm.Model 包含基本字段：ID、CreatedAt、UpdatedAt、DeletedAt。
 * 对应数据表字段为：id、created_at、updated_at、deleted_at。
 * 注意：
 * 1.复数表名：数据表名称是结构体名称的复数形式（users）。
 * 2.蛇形列名：列名是字段名的蛇形小写形式，用 `gorm:"column:user_name"` 指定列名。
 */
type User struct {
	//gorm.Model        // 继承 gorm.Model 的字段
	ID        int    `gorm:"type:int(10);primary_key;auto_increment"`
	Username  string `gorm:"type:varchar(20);default:'';comment:用户名"`
	CreatedAt int64  `gorm:"type:int(10);default:0;comment:创建时间"`
	ignore    string `gorm:"-"` // 忽略这个字段
}

// 设置 `User` 的表名，默认为：users
func (User) TableName() string {
	return "user"
}

/**
 * 钩子函数
 * BeforeCreate|AfterCreate
 * BeforeUpdate|AfterUpdate
 * BeforeSave|AfterSave
 * BeforeDelete|AfterDelete
 */
func (user *User) BeforeCreate(scope *gorm.Scope) error {
	scope.SetColumn("CreatedAt", time.Now().Unix())
	return nil
}

// 创建数据表
func CreateTable(db *gorm.DB, user *User) {
	if !db.HasTable(user) {
		err := db.Set("gorm:table_options", "ENGINE=InnoDB DEFAULT CHARSET=utf8").CreateTable(user).Error
		checkErr(err)
	}
}

func main() {
	// 可以通过定义 gorm.DefaultTableNameHandler 字段来对表名使用任何规则。
	/*gorm.DefaultTableNameHandler = func(db *gorm.DB, defaultTableName string) string {
		return "prefix_" + defaultTableName
	}*/

	// 初始化新的数据库连接，需要先导入 sql-driver，为方便记忆可以导入 gorm 封装的 driver
	// gorm.Open("mysql", "user:password@/dbname?charset=utf8&parseTime=True&loc=Local")
	db, err := gorm.Open("mysql", "root:root@/test")
	checkErr(err)

	defer db.Close()

	//user := User{}

	// 检查值的主键是否为空
	//fmt.Println("主键是否为空：", db.NewRecord(user))

	/**
	 * 创建
	 */
	//err = db.Create(&user).Error
	//checkErr(err)

	/**
	 * 查询
	 */
	// 接收单条数据
	user := User{}

	// 获取第一条、最后一条记录，按主键升序
	db.First(&user)
	db.Last(&user)

	// 通过主键查询（仅数字主键可用）
	db.First(&user, 50)
	fmt.Println(user)

	// 获取全部数据
	users := make([]User, 10) // 接收全部数据的切片
	db.Find(&users)
	fmt.Println(users)

	/**
	 * Where 查询 -- 原生
	 */
	db.Where("username = ? AND created_at > ?", "YCZ", 0).Find(&users)
	db.Raw("select * from user where username = ?", "YCZ4").Find(&users)
	fmt.Println(users)

	/**
	 * Where 查询 -- struct & map
	 * 当通过struct进行查询的时候，GORM 将会查询这些字段的非零值，字段为零值时，不会出现在查询条件中。
	 * 可以考虑适用指针类型或者 scanner/valuer 来避免这种情况。
	 */
	db.Where(User{Username: "YCZ3"}).Find(&users)

	// 多主键查询
	db.Where([]int{1, 2, 3, 4, 5}).Find(&users)
	fmt.Println(users)

	// Not 查询
	//db.Not().Find()

	// Or 查询
	//db.Where().Or().Find()

	// 额外条件查询
	//db.Set("gorm:query_option", "FOR UPDATE").First()

	/**
	 * FirstOrInit 未匹配到则初始化一条记录（仅适用于 struct 和 map 条件）
	 * FirstOrCreate 未匹配到则创建一条记录（仅适用于 struct 和 map 条件）
	 */
	// 获取第一条匹配的记录，或者通过给定的条件【初始化|创建】一条新记录
	//db.Where().FirstOrInit()
	//db.Where().FirstOrCreate()

	// 如果未查询到记录，通过给定的参数赋值给 struct ，然后使用这些值【初始化|创建】一条新记录。
	//db.Where(User{}).Attrs(User{}).FirstOrInit()
	//db.Where(User{}).Attrs(User{}).FirstOrCreate()

	// 无论是否查询到数据，都将参数赋值给 struct，然后【初始化|创建】或直接返回这条新记录。
	//db.Where(User{}).Assign(User{}).FirstOrInit()
	//db.Where(User{}).Assign(User{}).FirstOrCreate()

	/**
	 * 高级查询
	 */
	// 指定字段
	db.Select("id, username").Find(&users)
	fmt.Println(users)

	// 指定表名
	db.Table("user").Find(&users)
	fmt.Println(users)

	// Order
	//db.Where().Order().Find()

	// Limit
	//db.Limit().Find()

	// Offset

	// Count

	// Group Having

	// Joins

	// Pluck() 获取一列
	var usernames []string
	db.Find(&users).Pluck("username", &usernames)
	db.Model(&User{}).Pluck("username", &usernames)
	db.Table("user").Pluck("username", &usernames)
	fmt.Println(usernames)

	// Scan() 获取多列
	type customColumn struct {
		Username  string
		CreatedAt int
	}
	var columns []customColumn
	db.Table("user").Select("username, created_at").Scan(&columns)
	fmt.Println(columns)

	/**
	 * 更新
	 */
	// 1.更新所有字段（不管字段是否修改，生成的 SQL 语句会包含所有字段）
	var userUpd User
	db.Find(&userUpd, 5)
	userUpd.Username = "YCZ5"
	rows := db.Save(&userUpd).RowsAffected
	fmt.Println("影响行数：", rows)

	// 2.更新一个字段
	rows = db.Model(&userUpd).Update("username", "YYYY").RowsAffected
	fmt.Println("影响行数：", rows)

	// 3.更新多个字段
	// 当使用结构体更新的时候, GORM 只会更新那些非空的字段
	rows = db.Model(&userUpd).Updates(User{Username: "YY", CreatedAt: 5}).RowsAffected
	fmt.Println("影响行数：", rows)

	// 4.更新【指定|排除】字段
	rows = db.Model(&userUpd).Select("username").Updates(User{Username: "Select struct", CreatedAt: 4}).RowsAffected
	//rows = db.Model(&userUpd).Select("username").Updates(map[string]interface{}{"username": "Select", "created_at": 50}).RowsAffected
	fmt.Println("影响行数：", rows)
	rows = db.Model(&userUpd).Omit("username").Updates(User{Username: "Omit", CreatedAt: 50}).RowsAffected
	fmt.Println("影响行数：", rows)

	// 以上更新方式会触发 BeforeUpdate、AfterUpdate 钩子函数
	// 5.更新的钩子函数（不触发更新钩子函数）
	db.Model(&userUpd).UpdateColumn("username", "hello")
	db.Model(&userUpd).UpdateColumns(User{Username: "hello", CreatedAt: 18})

	// 6.批量更新（不会触发钩子函数）
	//db.Table("user").Updates(User{...})

	// 7.带表达式的更新
	//DB.Model(&product).Update("price", gorm.Expr("price * ? + ?", 2, 100))

	/**
	 * 删除|软删除
	 * 如果模型中有 DeletedAt 字段，它将自动拥有软删除的能力。
	 */
	// 1.删除一条记录
	//db.Delete(&user)
	// 2.批量删除
	//rows = db.Delete(User{}, "username", "YCZ").RowsAffected
	//rows = db.Where("username", "YCZ").Delete(User{})
	//fmt.Println("影响行数：", rows)

	// 使用 Unscoped 查询软删除记录
	//db.Unscoped().Where("age = 20").Find(&user)

	// 使用 Unscoped 永久删除记录
	//db.Unscoped().Delete(&user)

}
```



### （4）错误处理

> 鼓励在任何创建方法之后去检查错误。
>
> 创建方法就是那些会产生 SQL 查询并且发送到数据库，通常它就是一些 CRUD 方法， 就像:
>
> `Create`, `First`, `Find`, `Take`, `Save`, `UpdateXXX`, `Delete`, `Scan`, `Row`, `Rows`...

```go
// 基本上所有的函数都是链式的，全部都返回 db 对象，任何时候调用 db.Error 就能获取到错误信息，非常方便。
err := db.Error

// 将所有发生的错误作为切片返回
err := db.GetErrors()

// RecordNotFound 未找到数据错误
if db.RecordNotFound() {
	// 未找到数据
}
```

### （5）钩子函数

- 创建

```
// 开启事务
BeforeSave
BeforeCreate
// 连表前的保存
// 更新时间戳 `CreatedAt`, `UpdatedAt`
// 保存自己
// 重载哪些有默认值和空的字段
// 链表后的保存
AfterCreate
AfterSave
// 提交或回滚事务
```

- 更新

```
// 开启事务
BeforeSave
BeforeUpdate
// 链表前的保存
// 更新时间戳 `UpdatedAt`
// 保存自身
// 链表后的保存
AfterUpdate
AfterSave
// 提交或回滚的事务
```

- 删除

```
// 开启事务
BeforeDelete
// 删除自身
AfterDelete
// 提交或回滚事务
```

- 查询

```
// 从数据库中读取数据
// 加载之前 (急于加载)
AfterFind
```

### （6）事务

```
// 开启事务
tx := db.Begin()

// 在事务中执行一些数据库操作 （从这里开始使用 'tx'，而不是 'db'）
tx.Create(...)

// ...

// 发生错误回滚事务
tx.Rollback()

// 或者提交这个事务
tx.Commit()
```



## 七、Go 测试

### 1、测试命名规范

- 测试文件的命名规范：必须以 `_test.go` 结尾；
- 包的命名规范：
  - 白盒测试：测试文件和代码放在同一个包，可以使用不可导出的标识符；
  - 黑盒测试：测试文件和代码放在不同的包中。
- 函数的命名规范： 测试用例函数必须以 TestXxx、BenchmarkXxx、ExampleXxx 开头。
- 形参分别必须为：`t *testing.T` 或 ` b *testing.B ` 
- 变量的命名规范：为了清晰地表达函数的实际输出和预期输出，可以将两类输出命名为 got/want。

### 2、单元测试

> 编写测试用例：
>

```go
package test

func getSum(n int) int {
	var count int
	for i := 1; i <= n; i++ {
		count += i
	}
    
	return count
}
```

```go
// xxx_test.go

package test

import "testing"

// getSum() 的测试用例
func TestGetSum(t *testing.T) {
	got := getSum(100)
	if got != 5050 {
		t.Errorf("want getSum(100) = 5050, got = %d", got)
	}
}

// 批量测试
func TestGetSumBatch(t *testing.T) {
	tests := []struct {
		x    int
		want int
	}{
		{10, 55},
		{100, 5050},
	}
	for _, tt := range tests {
		t.Run("", func(t *testing.T) {
			if got := getSum(tt.x); got != tt.want {
				t.Errorf("getSum() = %v, want %v", got, tt.want)
			}
		})
	}
}
```

> 运行测试用例：
>

```
# 运行当前包下所有测试文件中的全部测试函数
go test

# 显示所有测试函数的运行细节：-v
go test -v

# 指定要执行的测试函数：-run < regexp>
go test -run 'TestGetSum'

# 指定执行测试函数的次数：-count N
go test -count 5

# 运行单个测试文件
go test -v origin_test.go origin.go
```

### 3、性能测试（压力测试）

>  性能测试的用例函数必须以 Benchmark 开头，如：BenchmarkXxx。
>
>  函数参数必须是 `*testing.B` 。

```go
func BenchmarkGetSum(b *testing.B) {
	for i := 0; i < b.N; i++ {
		getSum(i)
	}
}
```

> 运行测试用例：

```
# go test 命令默认不会执行性能测试函数，
# 需要通过指定参数 -bench 来运行性能测试函数。
go test -bench='.*'

Options：
	-bench='.*'		指定执行的测试函数（执行所有的压力测试函数）
	-benchmem		输出内存分配统计
	-benchtime=10s	指定测试时间和循环执行次数	# 指定测试时间
	-benchtime=100x 						# 指定测试次数
	-cpu=4			指定 GOMAXPROCS
	-timeout=10s	指定测试函数执行的超时时间
	
	-cpuprofile cpu.profile		生成CPU性能数据文件：cpu.profile
	-memprofile mem.profile		生成内存性能数据文件：mem.profile

# 运行测试
go test -bench='BenchmarkGetSum' -benchmem

goos: windows
goarch: amd64
pkg: test
cpu: Intel(R) Core(TM) i5-9400F CPU @ 2.90GHz
BenchmarkGetSum-6    944404    123454 ns/op    0 B/op    0 allocs/op

PASS
ok      test    116.882s

# 性能测试函数的执行结果：
BenchmarkGetSum-6    944404    123454 ns/op    0 B/op    0 allocs/op

# 结果解析
BenchmarkGetSum-6	测试函数名-6个CPU线程参与此次测试
944404				函数循环执行次数
123454 ns/op		每次循环的执行平均耗时（用时越少性能越高）
0 B/op				每次循环的平均内存消耗
0 allocs/op			每次循环的平均内存分配次数
```



### 5、自动化测试

```
go get -u github.com/cweill/gotests
```





## 八、Go 工程管理

### 1、Go 命令行工具

```
> go
Go is a tool for managing Go source code.

Usage:

        go <command> [arguments]

The commands are:

        bug         start a bug report
        build       compile packages and dependencies
        clean       remove object files and cached files
        doc         show documentation for package or symbol
        env         print Go environment information
        fix         update packages to use new APIs
        fmt         gofmt (reformat) package sources
        generate    generate Go files by processing source
        get         add dependencies to current module and install them
        install     compile and install packages and dependencies
        list        list packages or modules
        mod         module maintenance
        run         compile and run Go program
        test        test packages
        tool        run specified go tool
        version     print Go version
        vet         report likely mistakes in packages

Use "go help <command>" for more information about a command.

Additional help topics:

        buildconstraint build constraints
        buildmode       build modes
        c               calling between Go and C
        cache           build and test caching
        environment     environment variables
        filetype        file types
        go.mod          the go.mod file
        gopath          GOPATH environment variable
        gopath-get      legacy GOPATH go get
        goproxy         module proxy protocol
        importpath      import path syntax
        modules         modules, module versions, and more
        module-get      module-aware go get
        module-auth     module authentication using go.sum
        packages        package lists and patterns
        private         configuration for downloading non-public code
        testflag        testing flags
        testfunc        testing functions
        vcs             controlling version control with GOVCS

Use "go help <topic>" for more information about that topic.
```

### 2、代码风格



### 3、Go 项目布局

> [Standard Go Project Layout](https://github.com/golang-standards/project-layout)

```
project/
├─ api/                       API 层
│  ├─ admin/                  后台应用
│  │  ├─ v1/                  版本号 v1
│  │  │  ├─ example.go        ...
│  │  │  └─ ...
│  │  ├─ v2/                  版本号 v2
│  │  │  └─ ...               ...
│  │  └─ ...
│  ├─ app/                    前台应用
│  │  ├─ v1/                  版本号 v1
│  │  │  ├─ example.go        ...
│  │  │  └─ ...
│  │  ├─ v2/                  版本号 v2
│  │  │  └─ ...               ...
│  │  └─ ...
│  ├─ router                  路由层
│  │  └─ ...
│  └─ ...
├─ cmd/                       本项目的主干
│  ├─ admin/                  后台应用
│  │  ├─ base.service         服务启动脚本
│  │  ├─ build.sh             构建脚本
│  │  ├─ config.yaml          配置文件
│  │  ├─ Dockfile             docker 配置文件
│  │  ├─ docker-compose.yaml  docker-composer 配置文件
│  │  └─ main.go              入口文件
│  ├─ app/                    前台应用
│  │  └─ ...                  ...
│  └─ ...
├─ config/                    配置文件模板或默认配置
│  └─ ...                     ...
├─ initialize/                初始化层
│  └─ ...                     ...
├─ internal/                  私有应用程序和库代码（不局限于顶级 internal 目录）
│  ├─ admin/                  ...
│  │  └─ ...
│  ├─ app/
│  │  └─ ...
│  └─ ...
├─ model/                     模型层
│  ├─ config/                 配置模型
│  │  └─ ...                  ...
│  ├─ enum/                   系统枚举类型
│  │  ├─ timee/               时间枚举（命名规范：...e 枚举类型的后缀）
│  │  └─ ...                  ...
│  ├─ orm/                    DB 模型（ORM）
│  │  └─ ...                  ...
│  ├─ request/                请求结构
│  │  └─ ...                  ...
│  ├─ response/               响应结构
│  │  └─ ...                  ...
│  └─ ...
├─ pkg/                       外部应用程序可以使用的包（封包规范：尽可能简单、不依赖官方包外的其它包、在任意地方都可以直接运行、不包含业务逻辑）
│  ├─ cron/                   定时任务包
│  │  └─ ...                  ...
│  ├─ filex/                  文件操作包（命名规范：...x 与官方包重名时的封装）
│  │  └─ ...                  ...
│  ├─ httpx/                  http 请求封装包
│  │  └─ ...                  ...
│  ├─ logx/                   简单日志打印包
│  │  └─ ...                  ...
│  ├─ mq/                     mq 操作包
│  │  └─ ...                  ...
│  ├─ mysql/                  mysql 操作包
│  │  └─ ...                  ...
│  ├─ redis/                  redis 操作包
│  │  └─ ...                  ...
│  └─ ...                     
├─ service/                   服务层
│  ├─ basic/                  基础服务（文件上传、下载等）
│  │  └─ ...                  ...
│  ├─ bussiness/              业务服务
│  │  └─ ...                  ...
│  ├─ job/                    定时任务
│  │  └─ ...                  ...
│  ├─ middleware/             中间件服务
│  │  └─ ...                  ...
│  └─ ...
├─ vendor/                    应用程序依赖项（用 `go mod vendor` 创建 /vendor 目录）
│  └─ ...                     ...
├─ .gitignore
├─ go.mod
└─ README.md
```

### 4、文档管理









